{"ast":null,"code":"'use strict'; // Load modules\n\nconst Net = require('net');\n\nconst Hoek = require('hoek');\n\nconst Any = require('../any');\n\nconst Ref = require('../../ref');\n\nconst JoiDate = require('../date');\n\nconst Uri = require('./uri');\n\nconst Ip = require('./ip');\n\nlet Isemail; // Loaded on demand\n// Declare internals\n\nconst internals = {\n  uriRegex: Uri.createUriRegex(),\n  ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),\n  guidBrackets: {\n    '{': '}',\n    '[': ']',\n    '(': ')',\n    '': ''\n  },\n  guidVersions: {\n    uuidv1: '1',\n    uuidv2: '2',\n    uuidv3: '3',\n    uuidv4: '4',\n    uuidv5: '5'\n  },\n  cidrPresences: ['required', 'optional', 'forbidden'],\n  normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']\n};\ninternals.String = class extends Any {\n  constructor() {\n    super();\n    this._type = 'string';\n\n    this._invalids.add('');\n  }\n\n  _base(value, state, options) {\n    if (typeof value === 'string' && options.convert) {\n      if (this._flags.normalize) {\n        value = value.normalize(this._flags.normalize);\n      }\n\n      if (this._flags.case) {\n        value = this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();\n      }\n\n      if (this._flags.trim) {\n        value = value.trim();\n      }\n\n      if (this._inner.replacements) {\n        for (let i = 0; i < this._inner.replacements.length; ++i) {\n          const replacement = this._inner.replacements[i];\n          value = value.replace(replacement.pattern, replacement.replacement);\n        }\n      }\n\n      if (this._flags.truncate) {\n        for (let i = 0; i < this._tests.length; ++i) {\n          const test = this._tests[i];\n\n          if (test.name === 'max') {\n            value = value.slice(0, test.arg);\n            break;\n          }\n        }\n      }\n\n      if (this._flags.byteAligned && value.length % 2 !== 0) {\n        value = `0${value}`;\n      }\n    }\n\n    return {\n      value,\n      errors: typeof value === 'string' ? null : this.createError('string.base', {\n        value\n      }, state, options)\n    };\n  }\n\n  insensitive() {\n    if (this._flags.insensitive) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.insensitive = true;\n    return obj;\n  }\n\n  creditCard() {\n    return this._test('creditCard', undefined, function (value, state, options) {\n      let i = value.length;\n      let sum = 0;\n      let mul = 1;\n\n      while (i--) {\n        const char = value.charAt(i) * mul;\n        sum = sum + (char - (char > 9) * 9);\n        mul = mul ^ 3;\n      }\n\n      const check = sum % 10 === 0 && sum > 0;\n      return check ? value : this.createError('string.creditCard', {\n        value\n      }, state, options);\n    });\n  }\n\n  regex(pattern, patternOptions) {\n    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n    Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n    const patternObject = {\n      pattern\n    };\n\n    if (typeof patternOptions === 'string') {\n      patternObject.name = patternOptions;\n    } else if (typeof patternOptions === 'object') {\n      patternObject.invert = !!patternOptions.invert;\n\n      if (patternOptions.name) {\n        patternObject.name = patternOptions.name;\n      }\n    }\n\n    const errorCode = ['string.regex', patternObject.invert ? '.invert' : '', patternObject.name ? '.name' : '.base'].join('');\n    return this._test('regex', patternObject, function (value, state, options) {\n      const patternMatch = patternObject.pattern.test(value);\n\n      if (patternMatch ^ patternObject.invert) {\n        return value;\n      }\n\n      return this.createError(errorCode, {\n        name: patternObject.name,\n        pattern: patternObject.pattern,\n        value\n      }, state, options);\n    });\n  }\n\n  alphanum() {\n    return this._test('alphanum', undefined, function (value, state, options) {\n      if (/^[a-zA-Z0-9]+$/.test(value)) {\n        return value;\n      }\n\n      return this.createError('string.alphanum', {\n        value\n      }, state, options);\n    });\n  }\n\n  token() {\n    return this._test('token', undefined, function (value, state, options) {\n      if (/^\\w+$/.test(value)) {\n        return value;\n      }\n\n      return this.createError('string.token', {\n        value\n      }, state, options);\n    });\n  }\n\n  email(isEmailOptions) {\n    if (isEmailOptions) {\n      Hoek.assert(typeof isEmailOptions === 'object', 'email options must be an object');\n      Hoek.assert(typeof isEmailOptions.checkDNS === 'undefined', 'checkDNS option is not supported');\n      Hoek.assert(typeof isEmailOptions.tldWhitelist === 'undefined' || typeof isEmailOptions.tldWhitelist === 'object', 'tldWhitelist must be an array or object');\n      Hoek.assert(typeof isEmailOptions.minDomainAtoms === 'undefined' || Number.isSafeInteger(isEmailOptions.minDomainAtoms) && isEmailOptions.minDomainAtoms > 0, 'minDomainAtoms must be a positive integer');\n      Hoek.assert(typeof isEmailOptions.errorLevel === 'undefined' || typeof isEmailOptions.errorLevel === 'boolean' || Number.isSafeInteger(isEmailOptions.errorLevel) && isEmailOptions.errorLevel >= 0, 'errorLevel must be a non-negative integer or boolean');\n    }\n\n    return this._test('email', isEmailOptions, function (value, state, options) {\n      Isemail = Isemail || require('isemail');\n\n      try {\n        const result = Isemail.validate(value, isEmailOptions);\n\n        if (result === true || result === 0) {\n          return value;\n        }\n      } catch (e) {}\n\n      return this.createError('string.email', {\n        value\n      }, state, options);\n    });\n  }\n\n  ip(ipOptions = {}) {\n    let regex = internals.ipRegex;\n    Hoek.assert(typeof ipOptions === 'object', 'options must be an object');\n\n    if (ipOptions.cidr) {\n      Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');\n      ipOptions.cidr = ipOptions.cidr.toLowerCase();\n      Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', ')); // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is \"optional\" since that is the default\n\n      if (!ipOptions.version && ipOptions.cidr !== 'optional') {\n        regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);\n      }\n    } else {\n      // Set our default cidr strategy\n      ipOptions.cidr = 'optional';\n    }\n\n    let versions;\n\n    if (ipOptions.version) {\n      if (!Array.isArray(ipOptions.version)) {\n        ipOptions.version = [ipOptions.version];\n      }\n\n      Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');\n      versions = [];\n\n      for (let i = 0; i < ipOptions.version.length; ++i) {\n        let version = ipOptions.version[i];\n        Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n        version = version.toLowerCase();\n        Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));\n        versions.push(version);\n      } // Make sure we have a set of versions\n\n\n      versions = Array.from(new Set(versions));\n      regex = Ip.createIpRegex(versions, ipOptions.cidr);\n    }\n\n    return this._test('ip', ipOptions, function (value, state, options) {\n      if (regex.test(value)) {\n        return value;\n      }\n\n      if (versions) {\n        return this.createError('string.ipVersion', {\n          value,\n          cidr: ipOptions.cidr,\n          version: versions\n        }, state, options);\n      }\n\n      return this.createError('string.ip', {\n        value,\n        cidr: ipOptions.cidr\n      }, state, options);\n    });\n  }\n\n  uri(uriOptions) {\n    let customScheme = '';\n    let allowRelative = false;\n    let relativeOnly = false;\n    let allowQuerySquareBrackets = false;\n    let regex = internals.uriRegex;\n\n    if (uriOptions) {\n      Hoek.assert(typeof uriOptions === 'object', 'options must be an object');\n      const unknownOptions = Object.keys(uriOptions).filter(key => !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets'].includes(key));\n      Hoek.assert(unknownOptions.length === 0, `options contain unknown keys: ${unknownOptions}`);\n\n      if (uriOptions.scheme) {\n        Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');\n\n        if (!Array.isArray(uriOptions.scheme)) {\n          uriOptions.scheme = [uriOptions.scheme];\n        }\n\n        Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified'); // Flatten the array into a string to be used to match the schemes.\n\n        for (let i = 0; i < uriOptions.scheme.length; ++i) {\n          const scheme = uriOptions.scheme[i];\n          Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String'); // Add OR separators if a value already exists\n\n          customScheme = customScheme + (customScheme ? '|' : ''); // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.\n\n          if (scheme instanceof RegExp) {\n            customScheme = customScheme + scheme.source;\n          } else {\n            Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');\n            customScheme = customScheme + Hoek.escapeRegex(scheme);\n          }\n        }\n      }\n\n      if (uriOptions.allowRelative) {\n        allowRelative = true;\n      }\n\n      if (uriOptions.relativeOnly) {\n        relativeOnly = true;\n      }\n\n      if (uriOptions.allowQuerySquareBrackets) {\n        allowQuerySquareBrackets = true;\n      }\n    }\n\n    if (customScheme || allowRelative || relativeOnly || allowQuerySquareBrackets) {\n      regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly, allowQuerySquareBrackets);\n    }\n\n    return this._test('uri', uriOptions, function (value, state, options) {\n      if (regex.test(value)) {\n        return value;\n      }\n\n      if (relativeOnly) {\n        return this.createError('string.uriRelativeOnly', {\n          value\n        }, state, options);\n      }\n\n      if (customScheme) {\n        return this.createError('string.uriCustomScheme', {\n          scheme: customScheme,\n          value\n        }, state, options);\n      }\n\n      return this.createError('string.uri', {\n        value\n      }, state, options);\n    });\n  }\n\n  isoDate() {\n    return this._test('isoDate', undefined, function (value, state, options) {\n      if (JoiDate._isIsoDate(value)) {\n        if (!options.convert) {\n          return value;\n        }\n\n        const d = new Date(value);\n\n        if (!isNaN(d.getTime())) {\n          return d.toISOString();\n        }\n      }\n\n      return this.createError('string.isoDate', {\n        value\n      }, state, options);\n    });\n  }\n\n  guid(guidOptions) {\n    let versionNumbers = '';\n\n    if (guidOptions && guidOptions.version) {\n      if (!Array.isArray(guidOptions.version)) {\n        guidOptions.version = [guidOptions.version];\n      }\n\n      Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');\n      const versions = new Set();\n\n      for (let i = 0; i < guidOptions.version.length; ++i) {\n        let version = guidOptions.version[i];\n        Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n        version = version.toLowerCase();\n        const versionNumber = internals.guidVersions[version];\n        Hoek.assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));\n        Hoek.assert(!versions.has(versionNumber), 'version at position ' + i + ' must not be a duplicate.');\n        versionNumbers += versionNumber;\n        versions.add(versionNumber);\n      }\n    }\n\n    const guidRegex = new RegExp(`^([\\\\[{\\\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$`, 'i');\n    return this._test('guid', guidOptions, function (value, state, options) {\n      const results = guidRegex.exec(value);\n\n      if (!results) {\n        return this.createError('string.guid', {\n          value\n        }, state, options);\n      } // Matching braces\n\n\n      if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n        return this.createError('string.guid', {\n          value\n        }, state, options);\n      }\n\n      return value;\n    });\n  }\n\n  hex(hexOptions = {}) {\n    Hoek.assert(typeof hexOptions === 'object', 'hex options must be an object');\n    Hoek.assert(typeof hexOptions.byteAligned === 'undefined' || typeof hexOptions.byteAligned === 'boolean', 'byteAligned must be boolean');\n    const byteAligned = hexOptions.byteAligned === true;\n    const regex = /^[a-f0-9]+$/i;\n\n    const obj = this._test('hex', regex, function (value, state, options) {\n      if (regex.test(value)) {\n        if (byteAligned && value.length % 2 !== 0) {\n          return this.createError('string.hexAlign', {\n            value\n          }, state, options);\n        }\n\n        return value;\n      }\n\n      return this.createError('string.hex', {\n        value\n      }, state, options);\n    });\n\n    if (byteAligned) {\n      obj._flags.byteAligned = true;\n    }\n\n    return obj;\n  }\n\n  base64(base64Options = {}) {\n    // Validation.\n    Hoek.assert(typeof base64Options === 'object', 'base64 options must be an object');\n    Hoek.assert(typeof base64Options.paddingRequired === 'undefined' || typeof base64Options.paddingRequired === 'boolean', 'paddingRequired must be boolean'); // Determine if padding is required.\n\n    const paddingRequired = base64Options.paddingRequired === false ? base64Options.paddingRequired : base64Options.paddingRequired || true; // Set validation based on preference.\n\n    const regex = paddingRequired ? // Padding is required.\n    /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/ // Padding is optional.\n    : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n    return this._test('base64', regex, function (value, state, options) {\n      if (regex.test(value)) {\n        return value;\n      }\n\n      return this.createError('string.base64', {\n        value\n      }, state, options);\n    });\n  }\n\n  dataUri(dataUriOptions = {}) {\n    const regex = /^data:[\\w+.-]+\\/[\\w+.-]+;((charset=[\\w-]+|base64),)?(.*)$/; // Determine if padding is required.\n\n    const paddingRequired = dataUriOptions.paddingRequired === false ? dataUriOptions.paddingRequired : dataUriOptions.paddingRequired || true;\n    const base64regex = paddingRequired ? /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/ : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n    return this._test('dataUri', regex, function (value, state, options) {\n      const matches = value.match(regex);\n\n      if (matches) {\n        if (!matches[2]) {\n          return value;\n        }\n\n        if (matches[2] !== 'base64') {\n          return value;\n        }\n\n        if (base64regex.test(matches[3])) {\n          return value;\n        }\n      }\n\n      return this.createError('string.dataUri', {\n        value\n      }, state, options);\n    });\n  }\n\n  hostname() {\n    const regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n    return this._test('hostname', undefined, function (value, state, options) {\n      if (value.length <= 255 && regex.test(value) || Net.isIPv6(value)) {\n        return value;\n      }\n\n      return this.createError('string.hostname', {\n        value\n      }, state, options);\n    });\n  }\n\n  normalize(form = 'NFC') {\n    Hoek.assert(Hoek.contain(internals.normalizationForms, form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));\n\n    const obj = this._test('normalize', form, function (value, state, options) {\n      if (options.convert || value === value.normalize(form)) {\n        return value;\n      }\n\n      return this.createError('string.normalize', {\n        value,\n        form\n      }, state, options);\n    });\n\n    obj._flags.normalize = form;\n    return obj;\n  }\n\n  lowercase() {\n    const obj = this._test('lowercase', undefined, function (value, state, options) {\n      if (options.convert || value === value.toLocaleLowerCase()) {\n        return value;\n      }\n\n      return this.createError('string.lowercase', {\n        value\n      }, state, options);\n    });\n\n    obj._flags.case = 'lower';\n    return obj;\n  }\n\n  uppercase() {\n    const obj = this._test('uppercase', undefined, function (value, state, options) {\n      if (options.convert || value === value.toLocaleUpperCase()) {\n        return value;\n      }\n\n      return this.createError('string.uppercase', {\n        value\n      }, state, options);\n    });\n\n    obj._flags.case = 'upper';\n    return obj;\n  }\n\n  trim(enabled = true) {\n    Hoek.assert(typeof enabled === 'boolean', 'option must be a boolean');\n\n    if (this._flags.trim && enabled || !this._flags.trim && !enabled) {\n      return this;\n    }\n\n    let obj;\n\n    if (enabled) {\n      obj = this._test('trim', undefined, function (value, state, options) {\n        if (options.convert || value === value.trim()) {\n          return value;\n        }\n\n        return this.createError('string.trim', {\n          value\n        }, state, options);\n      });\n    } else {\n      obj = this.clone();\n      obj._tests = obj._tests.filter(test => test.name !== 'trim');\n    }\n\n    obj._flags.trim = enabled;\n    return obj;\n  }\n\n  replace(pattern, replacement) {\n    if (typeof pattern === 'string') {\n      pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');\n    }\n\n    Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n    Hoek.assert(typeof replacement === 'string', 'replacement must be a String'); // This can not be considere a test like trim, we can't \"reject\"\n    // anything from this rule, so just clone the current object\n\n    const obj = this.clone();\n\n    if (!obj._inner.replacements) {\n      obj._inner.replacements = [];\n    }\n\n    obj._inner.replacements.push({\n      pattern,\n      replacement\n    });\n\n    return obj;\n  }\n\n  truncate(enabled) {\n    const value = enabled === undefined ? true : !!enabled;\n\n    if (this._flags.truncate === value) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.truncate = value;\n    return obj;\n  }\n\n};\n\ninternals.compare = function (type, compare) {\n  return function (limit, encoding) {\n    const isRef = Ref.isRef(limit);\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n    Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n    return this._test(type, limit, function (value, state, options) {\n      let compareTo;\n\n      if (isRef) {\n        compareTo = limit(state.reference || state.parent, options);\n\n        if (!Number.isSafeInteger(compareTo)) {\n          return this.createError('string.ref', {\n            ref: limit,\n            value: compareTo\n          }, state, options);\n        }\n      } else {\n        compareTo = limit;\n      }\n\n      if (compare(value, compareTo, encoding)) {\n        return value;\n      }\n\n      return this.createError('string.' + type, {\n        limit: compareTo,\n        value,\n        encoding\n      }, state, options);\n    });\n  };\n};\n\ninternals.String.prototype.min = internals.compare('min', (value, limit, encoding) => {\n  const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length >= limit;\n});\ninternals.String.prototype.max = internals.compare('max', (value, limit, encoding) => {\n  const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length <= limit;\n});\ninternals.String.prototype.length = internals.compare('length', (value, limit, encoding) => {\n  const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n  return length === limit;\n}); // Aliases\n\ninternals.String.prototype.uuid = internals.String.prototype.guid;\nmodule.exports = new internals.String();","map":{"version":3,"sources":["C:/vidly/vidly/node_modules/joi/lib/types/string/index.js"],"names":["Net","require","Hoek","Any","Ref","JoiDate","Uri","Ip","Isemail","internals","uriRegex","createUriRegex","ipRegex","createIpRegex","guidBrackets","guidVersions","uuidv1","uuidv2","uuidv3","uuidv4","uuidv5","cidrPresences","normalizationForms","String","constructor","_type","_invalids","add","_base","value","state","options","convert","_flags","normalize","case","toLocaleUpperCase","toLocaleLowerCase","trim","_inner","replacements","i","length","replacement","replace","pattern","truncate","_tests","test","name","slice","arg","byteAligned","errors","createError","insensitive","obj","clone","creditCard","_test","undefined","sum","mul","char","charAt","check","regex","patternOptions","assert","RegExp","flags","includes","patternObject","invert","errorCode","join","patternMatch","alphanum","token","email","isEmailOptions","checkDNS","tldWhitelist","minDomainAtoms","Number","isSafeInteger","errorLevel","result","validate","e","ip","ipOptions","cidr","toLowerCase","contain","version","versions","Array","isArray","Object","keys","push","from","Set","uri","uriOptions","customScheme","allowRelative","relativeOnly","allowQuerySquareBrackets","unknownOptions","filter","key","scheme","source","escapeRegex","isoDate","_isIsoDate","d","Date","isNaN","getTime","toISOString","guid","guidOptions","versionNumbers","versionNumber","has","guidRegex","results","exec","hex","hexOptions","base64","base64Options","paddingRequired","dataUri","dataUriOptions","base64regex","matches","match","hostname","isIPv6","form","lowercase","uppercase","enabled","compare","type","limit","encoding","isRef","Buffer","isEncoding","compareTo","reference","parent","ref","prototype","min","byteLength","max","uuid","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n// Load modules\n\nconst Net = require('net');\nconst Hoek = require('hoek');\nconst Any = require('../any');\nconst Ref = require('../../ref');\nconst JoiDate = require('../date');\nconst Uri = require('./uri');\nconst Ip = require('./ip');\n\nlet Isemail; // Loaded on demand\n\n// Declare internals\n\nconst internals = {\n    uriRegex: Uri.createUriRegex(),\n    ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),\n    guidBrackets: {\n        '{': '}', '[': ']', '(': ')', '': ''\n    },\n    guidVersions: {\n        uuidv1: '1',\n        uuidv2: '2',\n        uuidv3: '3',\n        uuidv4: '4',\n        uuidv5: '5'\n    },\n    cidrPresences: ['required', 'optional', 'forbidden'],\n    normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']\n};\n\ninternals.String = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'string';\n        this._invalids.add('');\n    }\n\n    _base(value, state, options) {\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            if (this._flags.normalize) {\n                value = value.normalize(this._flags.normalize);\n            }\n\n            if (this._flags.case) {\n                value = (this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase());\n            }\n\n            if (this._flags.trim) {\n                value = value.trim();\n            }\n\n            if (this._inner.replacements) {\n\n                for (let i = 0; i < this._inner.replacements.length; ++i) {\n                    const replacement = this._inner.replacements[i];\n                    value = value.replace(replacement.pattern, replacement.replacement);\n                }\n            }\n\n            if (this._flags.truncate) {\n                for (let i = 0; i < this._tests.length; ++i) {\n                    const test = this._tests[i];\n                    if (test.name === 'max') {\n                        value = value.slice(0, test.arg);\n                        break;\n                    }\n                }\n            }\n\n            if (this._flags.byteAligned && value.length % 2 !== 0) {\n                value = `0${value}`;\n            }\n        }\n\n        return {\n            value,\n            errors: (typeof value === 'string') ? null : this.createError('string.base', { value }, state, options)\n        };\n    }\n\n    insensitive() {\n\n        if (this._flags.insensitive) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.insensitive = true;\n        return obj;\n    }\n\n    creditCard() {\n\n        return this._test('creditCard', undefined, function (value, state, options) {\n\n            let i = value.length;\n            let sum = 0;\n            let mul = 1;\n\n            while (i--) {\n                const char = value.charAt(i) * mul;\n                sum = sum + (char - (char > 9) * 9);\n                mul = mul ^ 3;\n            }\n\n            const check = (sum % 10 === 0) && (sum > 0);\n            return check ? value : this.createError('string.creditCard', { value }, state, options);\n        });\n    }\n\n    regex(pattern, patternOptions) {\n\n        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n        Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n\n        const patternObject = { pattern };\n\n        if (typeof patternOptions === 'string') {\n            patternObject.name = patternOptions;\n        }\n        else if (typeof patternOptions === 'object') {\n            patternObject.invert = !!patternOptions.invert;\n\n            if (patternOptions.name) {\n                patternObject.name = patternOptions.name;\n            }\n        }\n\n        const errorCode = ['string.regex', patternObject.invert ? '.invert' : '', patternObject.name ? '.name' : '.base'].join('');\n\n        return this._test('regex', patternObject, function (value, state, options) {\n\n            const patternMatch = patternObject.pattern.test(value);\n\n            if (patternMatch ^ patternObject.invert) {\n                return value;\n            }\n\n            return this.createError(errorCode, { name: patternObject.name, pattern: patternObject.pattern, value }, state, options);\n        });\n    }\n\n    alphanum() {\n\n        return this._test('alphanum', undefined, function (value, state, options) {\n\n            if (/^[a-zA-Z0-9]+$/.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.alphanum', { value }, state, options);\n        });\n    }\n\n    token() {\n\n        return this._test('token', undefined, function (value, state, options) {\n\n            if (/^\\w+$/.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.token', { value }, state, options);\n        });\n    }\n\n    email(isEmailOptions) {\n\n        if (isEmailOptions) {\n            Hoek.assert(typeof isEmailOptions === 'object', 'email options must be an object');\n            Hoek.assert(typeof isEmailOptions.checkDNS === 'undefined', 'checkDNS option is not supported');\n            Hoek.assert(typeof isEmailOptions.tldWhitelist === 'undefined' ||\n                typeof isEmailOptions.tldWhitelist === 'object', 'tldWhitelist must be an array or object');\n            Hoek.assert(\n                typeof isEmailOptions.minDomainAtoms === 'undefined' ||\n                Number.isSafeInteger(isEmailOptions.minDomainAtoms) &&\n                isEmailOptions.minDomainAtoms > 0,\n                'minDomainAtoms must be a positive integer'\n            );\n            Hoek.assert(\n                typeof isEmailOptions.errorLevel === 'undefined' ||\n                typeof isEmailOptions.errorLevel === 'boolean' ||\n                (\n                    Number.isSafeInteger(isEmailOptions.errorLevel) &&\n                    isEmailOptions.errorLevel >= 0\n                ),\n                'errorLevel must be a non-negative integer or boolean'\n            );\n        }\n\n        return this._test('email', isEmailOptions, function (value, state, options) {\n\n            Isemail = Isemail || require('isemail');\n\n            try {\n                const result = Isemail.validate(value, isEmailOptions);\n                if (result === true || result === 0) {\n                    return value;\n                }\n            }\n            catch (e) { }\n\n            return this.createError('string.email', { value }, state, options);\n        });\n    }\n\n    ip(ipOptions = {}) {\n\n        let regex = internals.ipRegex;\n        Hoek.assert(typeof ipOptions === 'object', 'options must be an object');\n\n        if (ipOptions.cidr) {\n            Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');\n            ipOptions.cidr = ipOptions.cidr.toLowerCase();\n\n            Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', '));\n\n            // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is \"optional\" since that is the default\n            if (!ipOptions.version && ipOptions.cidr !== 'optional') {\n                regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);\n            }\n        }\n        else {\n\n            // Set our default cidr strategy\n            ipOptions.cidr = 'optional';\n        }\n\n        let versions;\n        if (ipOptions.version) {\n            if (!Array.isArray(ipOptions.version)) {\n                ipOptions.version = [ipOptions.version];\n            }\n\n            Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');\n\n            versions = [];\n            for (let i = 0; i < ipOptions.version.length; ++i) {\n                let version = ipOptions.version[i];\n                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n                version = version.toLowerCase();\n                Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));\n                versions.push(version);\n            }\n\n            // Make sure we have a set of versions\n            versions = Array.from(new Set(versions));\n\n            regex = Ip.createIpRegex(versions, ipOptions.cidr);\n        }\n\n        return this._test('ip', ipOptions, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            if (versions) {\n                return this.createError('string.ipVersion', { value, cidr: ipOptions.cidr, version: versions }, state, options);\n            }\n\n            return this.createError('string.ip', { value, cidr: ipOptions.cidr }, state, options);\n        });\n    }\n\n    uri(uriOptions) {\n\n        let customScheme = '';\n        let allowRelative = false;\n        let relativeOnly = false;\n        let allowQuerySquareBrackets = false;\n        let regex = internals.uriRegex;\n\n        if (uriOptions) {\n            Hoek.assert(typeof uriOptions === 'object', 'options must be an object');\n\n            const unknownOptions = Object.keys(uriOptions).filter((key) => !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets'].includes(key));\n            Hoek.assert(unknownOptions.length === 0, `options contain unknown keys: ${unknownOptions}`);\n\n            if (uriOptions.scheme) {\n                Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');\n\n                if (!Array.isArray(uriOptions.scheme)) {\n                    uriOptions.scheme = [uriOptions.scheme];\n                }\n\n                Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified');\n\n                // Flatten the array into a string to be used to match the schemes.\n                for (let i = 0; i < uriOptions.scheme.length; ++i) {\n                    const scheme = uriOptions.scheme[i];\n                    Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');\n\n                    // Add OR separators if a value already exists\n                    customScheme = customScheme + (customScheme ? '|' : '');\n\n                    // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.\n                    if (scheme instanceof RegExp) {\n                        customScheme = customScheme + scheme.source;\n                    }\n                    else {\n                        Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');\n                        customScheme = customScheme + Hoek.escapeRegex(scheme);\n                    }\n                }\n            }\n\n            if (uriOptions.allowRelative) {\n                allowRelative = true;\n            }\n\n            if (uriOptions.relativeOnly) {\n                relativeOnly = true;\n            }\n\n            if (uriOptions.allowQuerySquareBrackets) {\n                allowQuerySquareBrackets = true;\n            }\n        }\n\n        if (customScheme || allowRelative || relativeOnly || allowQuerySquareBrackets) {\n            regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly, allowQuerySquareBrackets);\n        }\n\n        return this._test('uri', uriOptions, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            if (relativeOnly) {\n                return this.createError('string.uriRelativeOnly', { value }, state, options);\n            }\n\n            if (customScheme) {\n                return this.createError('string.uriCustomScheme', { scheme: customScheme, value }, state, options);\n            }\n\n            return this.createError('string.uri', { value }, state, options);\n        });\n    }\n\n    isoDate() {\n\n        return this._test('isoDate', undefined, function (value, state, options) {\n\n            if (JoiDate._isIsoDate(value)) {\n                if (!options.convert) {\n                    return value;\n                }\n\n                const d = new Date(value);\n                if (!isNaN(d.getTime())) {\n                    return d.toISOString();\n                }\n            }\n\n            return this.createError('string.isoDate', { value }, state, options);\n        });\n    }\n\n    guid(guidOptions) {\n\n        let versionNumbers = '';\n\n        if (guidOptions && guidOptions.version) {\n            if (!Array.isArray(guidOptions.version)) {\n                guidOptions.version = [guidOptions.version];\n            }\n\n            Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');\n            const versions = new Set();\n\n            for (let i = 0; i < guidOptions.version.length; ++i) {\n                let version = guidOptions.version[i];\n                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n                version = version.toLowerCase();\n                const versionNumber = internals.guidVersions[version];\n                Hoek.assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));\n                Hoek.assert(!(versions.has(versionNumber)), 'version at position ' + i + ' must not be a duplicate.');\n\n                versionNumbers += versionNumber;\n                versions.add(versionNumber);\n            }\n        }\n\n        const guidRegex = new RegExp(`^([\\\\[{\\\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$`, 'i');\n\n        return this._test('guid', guidOptions, function (value, state, options) {\n\n            const results = guidRegex.exec(value);\n\n            if (!results) {\n                return this.createError('string.guid', { value }, state, options);\n            }\n\n            // Matching braces\n            if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n                return this.createError('string.guid', { value }, state, options);\n            }\n\n            return value;\n        });\n    }\n\n    hex(hexOptions = {}) {\n\n        Hoek.assert(typeof hexOptions === 'object', 'hex options must be an object');\n        Hoek.assert(typeof hexOptions.byteAligned === 'undefined' || typeof hexOptions.byteAligned === 'boolean',\n            'byteAligned must be boolean');\n\n        const byteAligned = hexOptions.byteAligned === true;\n        const regex = /^[a-f0-9]+$/i;\n\n        const obj = this._test('hex', regex, function (value, state, options) {\n\n            if (regex.test(value)) {\n                if (byteAligned && value.length % 2 !== 0) {\n                    return this.createError('string.hexAlign', { value }, state, options);\n                }\n\n                return value;\n            }\n\n            return this.createError('string.hex', { value }, state, options);\n        });\n\n        if (byteAligned) {\n            obj._flags.byteAligned = true;\n        }\n\n        return obj;\n    }\n\n    base64(base64Options = {}) {\n\n        // Validation.\n        Hoek.assert(typeof base64Options === 'object', 'base64 options must be an object');\n        Hoek.assert(typeof base64Options.paddingRequired === 'undefined' || typeof base64Options.paddingRequired === 'boolean',\n            'paddingRequired must be boolean');\n\n        // Determine if padding is required.\n        const paddingRequired = base64Options.paddingRequired === false ?\n            base64Options.paddingRequired\n            : base64Options.paddingRequired || true;\n\n        // Set validation based on preference.\n        const regex = paddingRequired ?\n            // Padding is required.\n            /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n            // Padding is optional.\n            : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n\n        return this._test('base64', regex, function (value, state, options) {\n\n            if (regex.test(value)) {\n                return value;\n            }\n\n            return this.createError('string.base64', { value }, state, options);\n        });\n    }\n\n    dataUri(dataUriOptions = {}) {\n\n        const regex = /^data:[\\w+.-]+\\/[\\w+.-]+;((charset=[\\w-]+|base64),)?(.*)$/;\n\n        // Determine if padding is required.\n        const paddingRequired = dataUriOptions.paddingRequired === false ?\n            dataUriOptions.paddingRequired\n            : dataUriOptions.paddingRequired || true;\n\n        const base64regex =  paddingRequired ?\n            /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n            : /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/;\n\n        return this._test('dataUri', regex, function (value, state, options) {\n\n            const matches = value.match(regex);\n\n            if (matches) {\n                if (!matches[2]) {\n                    return value;\n                }\n\n                if (matches[2] !== 'base64') {\n                    return value;\n                }\n\n                if (base64regex.test(matches[3])) {\n                    return value;\n                }\n            }\n\n            return this.createError('string.dataUri', { value }, state, options);\n        });\n    }\n\n    hostname() {\n\n        const regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\\-]*[A-Za-z0-9])$/;\n\n        return this._test('hostname', undefined, function (value, state, options) {\n\n            if ((value.length <= 255 && regex.test(value)) ||\n                Net.isIPv6(value)) {\n\n                return value;\n            }\n\n            return this.createError('string.hostname', { value }, state, options);\n        });\n    }\n\n    normalize(form = 'NFC') {\n\n        Hoek.assert(Hoek.contain(internals.normalizationForms, form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));\n\n        const obj = this._test('normalize', form, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.normalize(form)) {\n\n                return value;\n            }\n\n            return this.createError('string.normalize', { value, form }, state, options);\n        });\n\n        obj._flags.normalize = form;\n        return obj;\n    }\n\n    lowercase() {\n\n        const obj = this._test('lowercase', undefined, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.toLocaleLowerCase()) {\n\n                return value;\n            }\n\n            return this.createError('string.lowercase', { value }, state, options);\n        });\n\n        obj._flags.case = 'lower';\n        return obj;\n    }\n\n    uppercase() {\n\n        const obj = this._test('uppercase', undefined, function (value, state, options) {\n\n            if (options.convert ||\n                value === value.toLocaleUpperCase()) {\n\n                return value;\n            }\n\n            return this.createError('string.uppercase', { value }, state, options);\n        });\n\n        obj._flags.case = 'upper';\n        return obj;\n    }\n\n    trim(enabled = true) {\n\n        Hoek.assert(typeof enabled === 'boolean', 'option must be a boolean');\n\n        if ((this._flags.trim && enabled) || (!this._flags.trim && !enabled)) {\n            return this;\n        }\n\n        let obj;\n        if (enabled) {\n            obj = this._test('trim', undefined, function (value, state, options) {\n\n                if (options.convert ||\n                    value === value.trim()) {\n\n                    return value;\n                }\n\n                return this.createError('string.trim', { value }, state, options);\n            });\n        }\n        else {\n            obj = this.clone();\n            obj._tests = obj._tests.filter((test) => test.name !== 'trim');\n        }\n\n        obj._flags.trim = enabled;\n        return obj;\n    }\n\n    replace(pattern, replacement) {\n\n        if (typeof pattern === 'string') {\n            pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');\n        }\n\n        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n        Hoek.assert(typeof replacement === 'string', 'replacement must be a String');\n\n        // This can not be considere a test like trim, we can't \"reject\"\n        // anything from this rule, so just clone the current object\n        const obj = this.clone();\n\n        if (!obj._inner.replacements) {\n            obj._inner.replacements = [];\n        }\n\n        obj._inner.replacements.push({\n            pattern,\n            replacement\n        });\n\n        return obj;\n    }\n\n    truncate(enabled) {\n\n        const value = enabled === undefined ? true : !!enabled;\n\n        if (this._flags.truncate === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.truncate = value;\n        return obj;\n    }\n\n};\n\ninternals.compare = function (type, compare) {\n\n    return function (limit, encoding) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n        Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n\n        return this._test(type, limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!Number.isSafeInteger(compareTo)) {\n                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (compare(value, compareTo, encoding)) {\n                return value;\n            }\n\n            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);\n        });\n    };\n};\n\n\ninternals.String.prototype.min = internals.compare('min', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length >= limit;\n});\n\n\ninternals.String.prototype.max = internals.compare('max', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length <= limit;\n});\n\n\ninternals.String.prototype.length = internals.compare('length', (value, limit, encoding) => {\n\n    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;\n    return length === limit;\n});\n\n// Aliases\n\ninternals.String.prototype.uuid = internals.String.prototype.guid;\n\nmodule.exports = new internals.String();\n"]},"metadata":{},"sourceType":"script"}