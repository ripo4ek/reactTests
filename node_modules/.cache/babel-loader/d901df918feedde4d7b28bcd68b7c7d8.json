{"ast":null,"code":"'use strict'; // Load modules\n\nconst Hoek = require('hoek');\n\nconst Any = require('../any');\n\nconst Cast = require('../../cast');\n\nconst Ref = require('../../ref');\n\nconst State = require('../state'); // Declare internals\n\n\nconst internals = {};\n\ninternals.fastSplice = function (arr, i) {\n  let pos = i;\n\n  while (pos < arr.length) {\n    arr[pos++] = arr[pos];\n  }\n\n  --arr.length;\n};\n\ninternals.Array = class extends Any {\n  constructor() {\n    super();\n    this._type = 'array';\n    this._inner.items = [];\n    this._inner.ordereds = [];\n    this._inner.inclusions = [];\n    this._inner.exclusions = [];\n    this._inner.requireds = [];\n    this._flags.sparse = false;\n  }\n\n  _base(value, state, options) {\n    const result = {\n      value\n    };\n\n    if (typeof value === 'string' && options.convert) {\n      internals.safeParse(value, result);\n    }\n\n    let isArray = Array.isArray(result.value);\n    const wasArray = isArray;\n\n    if (options.convert && this._flags.single && !isArray) {\n      result.value = [result.value];\n      isArray = true;\n    }\n\n    if (!isArray) {\n      result.errors = this.createError('array.base', null, state, options);\n      return result;\n    }\n\n    if (this._inner.inclusions.length || this._inner.exclusions.length || this._inner.requireds.length || this._inner.ordereds.length || !this._flags.sparse) {\n      // Clone the array so that we don't modify the original\n      if (wasArray) {\n        result.value = result.value.slice(0);\n      }\n\n      result.errors = this._checkItems(result.value, wasArray, state, options);\n\n      if (result.errors && wasArray && options.convert && this._flags.single) {\n        // Attempt a 2nd pass by putting the array inside one.\n        const previousErrors = result.errors;\n        result.value = [result.value];\n        result.errors = this._checkItems(result.value, wasArray, state, options);\n\n        if (result.errors) {\n          // Restore previous errors and value since this didn't validate either.\n          result.errors = previousErrors;\n          result.value = result.value[0];\n        }\n      }\n    }\n\n    return result;\n  }\n\n  _checkItems(items, wasArray, state, options) {\n    const errors = [];\n    let errored;\n\n    const requireds = this._inner.requireds.slice();\n\n    const ordereds = this._inner.ordereds.slice();\n\n    const inclusions = [...this._inner.inclusions, ...requireds];\n    let il = items.length;\n\n    for (let i = 0; i < il; ++i) {\n      errored = false;\n      const item = items[i];\n      let isValid = false;\n      const key = wasArray ? i : state.key;\n      const path = wasArray ? [...state.path, i] : state.path;\n      const localState = new State(key, path, state.parent, state.reference);\n      let res; // Sparse\n\n      if (!this._flags.sparse && item === undefined) {\n        errors.push(this.createError('array.sparse', null, {\n          key: state.key,\n          path: localState.path,\n          pos: i\n        }, options));\n\n        if (options.abortEarly) {\n          return errors;\n        }\n\n        ordereds.shift();\n        continue;\n      } // Exclusions\n\n\n      for (let j = 0; j < this._inner.exclusions.length; ++j) {\n        res = this._inner.exclusions[j]._validate(item, localState, {}); // Not passing options to use defaults\n\n        if (!res.errors) {\n          errors.push(this.createError(wasArray ? 'array.excludes' : 'array.excludesSingle', {\n            pos: i,\n            value: item\n          }, {\n            key: state.key,\n            path: localState.path\n          }, options));\n          errored = true;\n\n          if (options.abortEarly) {\n            return errors;\n          }\n\n          ordereds.shift();\n          break;\n        }\n      }\n\n      if (errored) {\n        continue;\n      } // Ordered\n\n\n      if (this._inner.ordereds.length) {\n        if (ordereds.length > 0) {\n          const ordered = ordereds.shift();\n          res = ordered._validate(item, localState, options);\n\n          if (!res.errors) {\n            if (ordered._flags.strip) {\n              internals.fastSplice(items, i);\n              --i;\n              --il;\n            } else if (!this._flags.sparse && res.value === undefined) {\n              errors.push(this.createError('array.sparse', null, {\n                key: state.key,\n                path: localState.path,\n                pos: i\n              }, options));\n\n              if (options.abortEarly) {\n                return errors;\n              }\n\n              continue;\n            } else {\n              items[i] = res.value;\n            }\n          } else {\n            errors.push(this.createError('array.ordered', {\n              pos: i,\n              reason: res.errors,\n              value: item\n            }, {\n              key: state.key,\n              path: localState.path\n            }, options));\n\n            if (options.abortEarly) {\n              return errors;\n            }\n          }\n\n          continue;\n        } else if (!this._inner.items.length) {\n          errors.push(this.createError('array.orderedLength', {\n            pos: i,\n            limit: this._inner.ordereds.length\n          }, {\n            key: state.key,\n            path: localState.path\n          }, options));\n\n          if (options.abortEarly) {\n            return errors;\n          }\n\n          continue;\n        }\n      } // Requireds\n\n\n      const requiredChecks = [];\n      let jl = requireds.length;\n\n      for (let j = 0; j < jl; ++j) {\n        res = requiredChecks[j] = requireds[j]._validate(item, localState, options);\n\n        if (!res.errors) {\n          items[i] = res.value;\n          isValid = true;\n          internals.fastSplice(requireds, j);\n          --j;\n          --jl;\n\n          if (!this._flags.sparse && res.value === undefined) {\n            errors.push(this.createError('array.sparse', null, {\n              key: state.key,\n              path: localState.path,\n              pos: i\n            }, options));\n\n            if (options.abortEarly) {\n              return errors;\n            }\n          }\n\n          break;\n        }\n      }\n\n      if (isValid) {\n        continue;\n      } // Inclusions\n\n\n      const stripUnknown = options.stripUnknown && !!options.stripUnknown.arrays || false;\n      jl = inclusions.length;\n\n      for (let j = 0; j < jl; ++j) {\n        const inclusion = inclusions[j]; // Avoid re-running requireds that already didn't match in the previous loop\n\n        const previousCheck = requireds.indexOf(inclusion);\n\n        if (previousCheck !== -1) {\n          res = requiredChecks[previousCheck];\n        } else {\n          res = inclusion._validate(item, localState, options);\n\n          if (!res.errors) {\n            if (inclusion._flags.strip) {\n              internals.fastSplice(items, i);\n              --i;\n              --il;\n            } else if (!this._flags.sparse && res.value === undefined) {\n              errors.push(this.createError('array.sparse', null, {\n                key: state.key,\n                path: localState.path,\n                pos: i\n              }, options));\n              errored = true;\n            } else {\n              items[i] = res.value;\n            }\n\n            isValid = true;\n            break;\n          }\n        } // Return the actual error if only one inclusion defined\n\n\n        if (jl === 1) {\n          if (stripUnknown) {\n            internals.fastSplice(items, i);\n            --i;\n            --il;\n            isValid = true;\n            break;\n          }\n\n          errors.push(this.createError(wasArray ? 'array.includesOne' : 'array.includesOneSingle', {\n            pos: i,\n            reason: res.errors,\n            value: item\n          }, {\n            key: state.key,\n            path: localState.path\n          }, options));\n          errored = true;\n\n          if (options.abortEarly) {\n            return errors;\n          }\n\n          break;\n        }\n      }\n\n      if (errored) {\n        continue;\n      }\n\n      if (this._inner.inclusions.length && !isValid) {\n        if (stripUnknown) {\n          internals.fastSplice(items, i);\n          --i;\n          --il;\n          continue;\n        }\n\n        errors.push(this.createError(wasArray ? 'array.includes' : 'array.includesSingle', {\n          pos: i,\n          value: item\n        }, {\n          key: state.key,\n          path: localState.path\n        }, options));\n\n        if (options.abortEarly) {\n          return errors;\n        }\n      }\n    }\n\n    if (requireds.length) {\n      this._fillMissedErrors(errors, requireds, state, options);\n    }\n\n    if (ordereds.length) {\n      this._fillOrderedErrors(errors, ordereds, state, options);\n    }\n\n    return errors.length ? errors : null;\n  }\n\n  describe() {\n    const description = super.describe();\n\n    if (this._inner.ordereds.length) {\n      description.orderedItems = [];\n\n      for (let i = 0; i < this._inner.ordereds.length; ++i) {\n        description.orderedItems.push(this._inner.ordereds[i].describe());\n      }\n    }\n\n    if (this._inner.items.length) {\n      description.items = [];\n\n      for (let i = 0; i < this._inner.items.length; ++i) {\n        description.items.push(this._inner.items[i].describe());\n      }\n    }\n\n    if (description.rules) {\n      for (let i = 0; i < description.rules.length; ++i) {\n        const rule = description.rules[i];\n\n        if (rule.name === 'has') {\n          rule.arg = rule.arg.describe();\n        }\n      }\n    }\n\n    return description;\n  }\n\n  items(...schemas) {\n    const obj = this.clone();\n    Hoek.flatten(schemas).forEach((type, index) => {\n      try {\n        type = Cast.schema(this._currentJoi, type);\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.path = index + '.' + castErr.path;\n        } else {\n          castErr.path = index;\n        }\n\n        castErr.message = `${castErr.message}(${castErr.path})`;\n        throw castErr;\n      }\n\n      obj._inner.items.push(type);\n\n      if (type._flags.presence === 'required') {\n        obj._inner.requireds.push(type);\n      } else if (type._flags.presence === 'forbidden') {\n        obj._inner.exclusions.push(type.optional());\n      } else {\n        obj._inner.inclusions.push(type);\n      }\n    });\n    return obj;\n  }\n\n  ordered(...schemas) {\n    const obj = this.clone();\n    Hoek.flatten(schemas).forEach((type, index) => {\n      try {\n        type = Cast.schema(this._currentJoi, type);\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.path = index + '.' + castErr.path;\n        } else {\n          castErr.path = index;\n        }\n\n        castErr.message = `${castErr.message}(${castErr.path})`;\n        throw castErr;\n      }\n\n      obj._inner.ordereds.push(type);\n    });\n    return obj;\n  }\n\n  min(limit) {\n    const isRef = Ref.isRef(limit);\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n    return this._testUnique('min', limit, function (value, state, options) {\n      let compareTo;\n\n      if (isRef) {\n        compareTo = limit(state.reference || state.parent, options);\n\n        if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n          return this.createError('array.ref', {\n            ref: limit,\n            value: compareTo\n          }, state, options);\n        }\n      } else {\n        compareTo = limit;\n      }\n\n      if (value.length >= compareTo) {\n        return value;\n      }\n\n      return this.createError('array.min', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  max(limit) {\n    const isRef = Ref.isRef(limit);\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n    return this._testUnique('max', limit, function (value, state, options) {\n      let compareTo;\n\n      if (isRef) {\n        compareTo = limit(state.reference || state.parent, options);\n\n        if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n          return this.createError('array.ref', {\n            ref: limit.key\n          }, state, options);\n        }\n      } else {\n        compareTo = limit;\n      }\n\n      if (value.length <= compareTo) {\n        return value;\n      }\n\n      return this.createError('array.max', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  length(limit) {\n    const isRef = Ref.isRef(limit);\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0 || isRef, 'limit must be a positive integer or reference');\n    return this._testUnique('length', limit, function (value, state, options) {\n      let compareTo;\n\n      if (isRef) {\n        compareTo = limit(state.reference || state.parent, options);\n\n        if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n          return this.createError('array.ref', {\n            ref: limit.key\n          }, state, options);\n        }\n      } else {\n        compareTo = limit;\n      }\n\n      if (value.length === compareTo) {\n        return value;\n      }\n\n      return this.createError('array.length', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  has(schema) {\n    try {\n      schema = Cast.schema(this._currentJoi, schema);\n    } catch (castErr) {\n      if (castErr.hasOwnProperty('path')) {\n        castErr.message = `${castErr.message}(${castErr.path})`;\n      }\n\n      throw castErr;\n    }\n\n    return this._test('has', schema, function (value, state, options) {\n      const isValid = value.some((item, idx) => {\n        const localState = new State(idx, [...state.path, idx], state.key, state.reference);\n        return !schema._validate(item, localState, options).errors;\n      });\n\n      if (isValid) {\n        return value;\n      }\n\n      const patternLabel = schema._getLabel();\n\n      if (patternLabel) {\n        return this.createError('array.hasKnown', {\n          patternLabel\n        }, state, options);\n      }\n\n      return this.createError('array.hasUnknown', null, state, options);\n    });\n  }\n\n  unique(comparator, configs) {\n    Hoek.assert(comparator === undefined || typeof comparator === 'function' || typeof comparator === 'string', 'comparator must be a function or a string');\n    Hoek.assert(configs === undefined || typeof configs === 'object', 'configs must be an object');\n    const settings = {\n      ignoreUndefined: configs && configs.ignoreUndefined || false\n    };\n\n    if (typeof comparator === 'string') {\n      settings.path = comparator;\n    } else if (typeof comparator === 'function') {\n      settings.comparator = comparator;\n    }\n\n    return this._test('unique', settings, function (value, state, options) {\n      const found = {\n        string: Object.create(null),\n        number: Object.create(null),\n        undefined: Object.create(null),\n        boolean: Object.create(null),\n        object: new Map(),\n        function: new Map(),\n        custom: new Map()\n      };\n      const compare = settings.comparator || Hoek.deepEqual;\n      const ignoreUndefined = settings.ignoreUndefined;\n\n      for (let i = 0; i < value.length; ++i) {\n        const item = settings.path ? Hoek.reach(value[i], settings.path) : value[i];\n        const records = settings.comparator ? found.custom : found[typeof item]; // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.\n        // I still want to keep the test for future js versions with new types (eg. Symbol).\n\n        if (\n        /* $lab:coverage:off$ */\n        records\n        /* $lab:coverage:on$ */\n        ) {\n            if (records instanceof Map) {\n              const entries = records.entries();\n              let current;\n\n              while (!(current = entries.next()).done) {\n                if (compare(current.value[0], item)) {\n                  const localState = new State(state.key, [...state.path, i], state.parent, state.reference);\n                  const context = {\n                    pos: i,\n                    value: value[i],\n                    dupePos: current.value[1],\n                    dupeValue: value[current.value[1]]\n                  };\n\n                  if (settings.path) {\n                    context.path = settings.path;\n                  }\n\n                  return this.createError('array.unique', context, localState, options);\n                }\n              }\n\n              records.set(item, i);\n            } else {\n              if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {\n                const localState = new State(state.key, [...state.path, i], state.parent, state.reference);\n                const context = {\n                  pos: i,\n                  value: value[i],\n                  dupePos: records[item],\n                  dupeValue: value[records[item]]\n                };\n\n                if (settings.path) {\n                  context.path = settings.path;\n                }\n\n                return this.createError('array.unique', context, localState, options);\n              }\n\n              records[item] = i;\n            }\n          }\n      }\n\n      return value;\n    });\n  }\n\n  sparse(enabled) {\n    const value = enabled === undefined ? true : !!enabled;\n\n    if (this._flags.sparse === value) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.sparse = value;\n    return obj;\n  }\n\n  single(enabled) {\n    const value = enabled === undefined ? true : !!enabled;\n\n    if (this._flags.single === value) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.single = value;\n    return obj;\n  }\n\n  _fillMissedErrors(errors, requireds, state, options) {\n    const knownMisses = [];\n    let unknownMisses = 0;\n\n    for (let i = 0; i < requireds.length; ++i) {\n      const label = requireds[i]._getLabel();\n\n      if (label) {\n        knownMisses.push(label);\n      } else {\n        ++unknownMisses;\n      }\n    }\n\n    if (knownMisses.length) {\n      if (unknownMisses) {\n        errors.push(this.createError('array.includesRequiredBoth', {\n          knownMisses,\n          unknownMisses\n        }, {\n          key: state.key,\n          path: state.path\n        }, options));\n      } else {\n        errors.push(this.createError('array.includesRequiredKnowns', {\n          knownMisses\n        }, {\n          key: state.key,\n          path: state.path\n        }, options));\n      }\n    } else {\n      errors.push(this.createError('array.includesRequiredUnknowns', {\n        unknownMisses\n      }, {\n        key: state.key,\n        path: state.path\n      }, options));\n    }\n  }\n\n  _fillOrderedErrors(errors, ordereds, state, options) {\n    const requiredOrdereds = [];\n\n    for (let i = 0; i < ordereds.length; ++i) {\n      const presence = Hoek.reach(ordereds[i], '_flags.presence');\n\n      if (presence === 'required') {\n        requiredOrdereds.push(ordereds[i]);\n      }\n    }\n\n    if (requiredOrdereds.length) {\n      this._fillMissedErrors(errors, requiredOrdereds, state, options);\n    }\n  }\n\n};\n\ninternals.safeParse = function (value, result) {\n  try {\n    const converted = JSON.parse(value);\n\n    if (Array.isArray(converted)) {\n      result.value = converted;\n    }\n  } catch (e) {}\n};\n\nmodule.exports = new internals.Array();","map":{"version":3,"sources":["C:/vidly/vidly/node_modules/joi/lib/types/array/index.js"],"names":["Hoek","require","Any","Cast","Ref","State","internals","fastSplice","arr","i","pos","length","Array","constructor","_type","_inner","items","ordereds","inclusions","exclusions","requireds","_flags","sparse","_base","value","state","options","result","convert","safeParse","isArray","wasArray","single","errors","createError","slice","_checkItems","previousErrors","errored","il","item","isValid","key","path","localState","parent","reference","res","undefined","push","abortEarly","shift","j","_validate","ordered","strip","reason","limit","requiredChecks","jl","stripUnknown","arrays","inclusion","previousCheck","indexOf","_fillMissedErrors","_fillOrderedErrors","describe","description","orderedItems","rules","rule","name","arg","schemas","obj","clone","flatten","forEach","type","index","schema","_currentJoi","castErr","hasOwnProperty","message","presence","optional","min","isRef","assert","Number","isSafeInteger","_testUnique","compareTo","ref","max","has","_test","some","idx","patternLabel","_getLabel","unique","comparator","configs","settings","ignoreUndefined","found","string","Object","create","number","boolean","object","Map","function","custom","compare","deepEqual","reach","records","entries","current","next","done","context","dupePos","dupeValue","set","enabled","knownMisses","unknownMisses","label","requiredOrdereds","converted","JSON","parse","e","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\n\nconst Any = require('../any');\nconst Cast = require('../../cast');\nconst Ref = require('../../ref');\nconst State = require('../state');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.fastSplice = function (arr, i) {\n\n    let pos = i;\n    while (pos < arr.length) {\n        arr[pos++] = arr[pos];\n    }\n\n    --arr.length;\n};\n\n\ninternals.Array = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'array';\n        this._inner.items = [];\n        this._inner.ordereds = [];\n        this._inner.inclusions = [];\n        this._inner.exclusions = [];\n        this._inner.requireds = [];\n        this._flags.sparse = false;\n    }\n\n    _base(value, state, options) {\n\n        const result = {\n            value\n        };\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            internals.safeParse(value, result);\n        }\n\n        let isArray = Array.isArray(result.value);\n        const wasArray = isArray;\n        if (options.convert && this._flags.single && !isArray) {\n            result.value = [result.value];\n            isArray = true;\n        }\n\n        if (!isArray) {\n            result.errors = this.createError('array.base', null, state, options);\n            return result;\n        }\n\n        if (this._inner.inclusions.length ||\n            this._inner.exclusions.length ||\n            this._inner.requireds.length ||\n            this._inner.ordereds.length ||\n            !this._flags.sparse) {\n\n            // Clone the array so that we don't modify the original\n            if (wasArray) {\n                result.value = result.value.slice(0);\n            }\n\n            result.errors = this._checkItems(result.value, wasArray, state, options);\n\n            if (result.errors && wasArray && options.convert && this._flags.single) {\n\n                // Attempt a 2nd pass by putting the array inside one.\n                const previousErrors = result.errors;\n\n                result.value = [result.value];\n                result.errors = this._checkItems(result.value, wasArray, state, options);\n\n                if (result.errors) {\n\n                    // Restore previous errors and value since this didn't validate either.\n                    result.errors = previousErrors;\n                    result.value = result.value[0];\n                }\n            }\n        }\n\n        return result;\n    }\n\n    _checkItems(items, wasArray, state, options) {\n\n        const errors = [];\n        let errored;\n\n        const requireds = this._inner.requireds.slice();\n        const ordereds = this._inner.ordereds.slice();\n        const inclusions = [...this._inner.inclusions, ...requireds];\n\n        let il = items.length;\n        for (let i = 0; i < il; ++i) {\n            errored = false;\n            const item = items[i];\n            let isValid = false;\n            const key = wasArray ? i : state.key;\n            const path = wasArray ? [...state.path, i] : state.path;\n            const localState = new State(key, path, state.parent, state.reference);\n            let res;\n\n            // Sparse\n\n            if (!this._flags.sparse && item === undefined) {\n                errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n\n                if (options.abortEarly) {\n                    return errors;\n                }\n\n                ordereds.shift();\n\n                continue;\n            }\n\n            // Exclusions\n\n            for (let j = 0; j < this._inner.exclusions.length; ++j) {\n                res = this._inner.exclusions[j]._validate(item, localState, {});                // Not passing options to use defaults\n\n                if (!res.errors) {\n                    errors.push(this.createError(wasArray ? 'array.excludes' : 'array.excludesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));\n                    errored = true;\n\n                    if (options.abortEarly) {\n                        return errors;\n                    }\n\n                    ordereds.shift();\n\n                    break;\n                }\n            }\n\n            if (errored) {\n                continue;\n            }\n\n            // Ordered\n            if (this._inner.ordereds.length) {\n                if (ordereds.length > 0) {\n                    const ordered = ordereds.shift();\n                    res = ordered._validate(item, localState, options);\n                    if (!res.errors) {\n                        if (ordered._flags.strip) {\n                            internals.fastSplice(items, i);\n                            --i;\n                            --il;\n                        }\n                        else if (!this._flags.sparse && res.value === undefined) {\n                            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n\n                            if (options.abortEarly) {\n                                return errors;\n                            }\n\n                            continue;\n                        }\n                        else {\n                            items[i] = res.value;\n                        }\n                    }\n                    else {\n                        errors.push(this.createError('array.ordered', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));\n                        if (options.abortEarly) {\n                            return errors;\n                        }\n                    }\n\n                    continue;\n                }\n                else if (!this._inner.items.length) {\n                    errors.push(this.createError('array.orderedLength', { pos: i, limit: this._inner.ordereds.length }, { key: state.key, path: localState.path }, options));\n                    if (options.abortEarly) {\n                        return errors;\n                    }\n\n                    continue;\n                }\n            }\n\n            // Requireds\n\n            const requiredChecks = [];\n            let jl = requireds.length;\n            for (let j = 0; j < jl; ++j) {\n                res = requiredChecks[j] = requireds[j]._validate(item, localState, options);\n                if (!res.errors) {\n                    items[i] = res.value;\n                    isValid = true;\n                    internals.fastSplice(requireds, j);\n                    --j;\n                    --jl;\n\n                    if (!this._flags.sparse && res.value === undefined) {\n                        errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n\n                        if (options.abortEarly) {\n                            return errors;\n                        }\n                    }\n\n                    break;\n                }\n            }\n\n            if (isValid) {\n                continue;\n            }\n\n            // Inclusions\n\n            const stripUnknown = options.stripUnknown && !!options.stripUnknown.arrays || false;\n\n            jl = inclusions.length;\n            for (let j = 0; j < jl; ++j) {\n                const inclusion = inclusions[j];\n\n                // Avoid re-running requireds that already didn't match in the previous loop\n                const previousCheck = requireds.indexOf(inclusion);\n                if (previousCheck !== -1) {\n                    res = requiredChecks[previousCheck];\n                }\n                else {\n                    res = inclusion._validate(item, localState, options);\n\n                    if (!res.errors) {\n                        if (inclusion._flags.strip) {\n                            internals.fastSplice(items, i);\n                            --i;\n                            --il;\n                        }\n                        else if (!this._flags.sparse && res.value === undefined) {\n                            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));\n                            errored = true;\n                        }\n                        else {\n                            items[i] = res.value;\n                        }\n\n                        isValid = true;\n                        break;\n                    }\n                }\n\n                // Return the actual error if only one inclusion defined\n                if (jl === 1) {\n                    if (stripUnknown) {\n                        internals.fastSplice(items, i);\n                        --i;\n                        --il;\n                        isValid = true;\n                        break;\n                    }\n\n                    errors.push(this.createError(wasArray ? 'array.includesOne' : 'array.includesOneSingle', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));\n                    errored = true;\n\n                    if (options.abortEarly) {\n                        return errors;\n                    }\n\n                    break;\n                }\n            }\n\n            if (errored) {\n                continue;\n            }\n\n            if (this._inner.inclusions.length && !isValid) {\n                if (stripUnknown) {\n                    internals.fastSplice(items, i);\n                    --i;\n                    --il;\n                    continue;\n                }\n\n                errors.push(this.createError(wasArray ? 'array.includes' : 'array.includesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));\n\n                if (options.abortEarly) {\n                    return errors;\n                }\n            }\n        }\n\n        if (requireds.length) {\n            this._fillMissedErrors(errors, requireds, state, options);\n        }\n\n        if (ordereds.length) {\n            this._fillOrderedErrors(errors, ordereds, state, options);\n        }\n\n        return errors.length ? errors : null;\n    }\n\n    describe() {\n\n        const description = super.describe();\n\n        if (this._inner.ordereds.length) {\n            description.orderedItems = [];\n\n            for (let i = 0; i < this._inner.ordereds.length; ++i) {\n                description.orderedItems.push(this._inner.ordereds[i].describe());\n            }\n        }\n\n        if (this._inner.items.length) {\n            description.items = [];\n\n            for (let i = 0; i < this._inner.items.length; ++i) {\n                description.items.push(this._inner.items[i].describe());\n            }\n        }\n\n        if (description.rules) {\n            for (let i = 0; i < description.rules.length; ++i) {\n                const rule = description.rules[i];\n                if (rule.name === 'has') {\n                    rule.arg = rule.arg.describe();\n                }\n            }\n        }\n\n        return description;\n    }\n\n    items(...schemas) {\n\n        const obj = this.clone();\n\n        Hoek.flatten(schemas).forEach((type, index) => {\n\n            try {\n                type = Cast.schema(this._currentJoi, type);\n            }\n            catch (castErr) {\n                if (castErr.hasOwnProperty('path')) {\n                    castErr.path = index + '.' + castErr.path;\n                }\n                else {\n                    castErr.path = index;\n                }\n\n                castErr.message = `${castErr.message}(${castErr.path})`;\n                throw castErr;\n            }\n\n            obj._inner.items.push(type);\n\n            if (type._flags.presence === 'required') {\n                obj._inner.requireds.push(type);\n            }\n            else if (type._flags.presence === 'forbidden') {\n                obj._inner.exclusions.push(type.optional());\n            }\n            else {\n                obj._inner.inclusions.push(type);\n            }\n        });\n\n        return obj;\n    }\n\n    ordered(...schemas) {\n\n        const obj = this.clone();\n\n        Hoek.flatten(schemas).forEach((type, index) => {\n\n            try {\n                type = Cast.schema(this._currentJoi, type);\n            }\n            catch (castErr) {\n                if (castErr.hasOwnProperty('path')) {\n                    castErr.path = index + '.' + castErr.path;\n                }\n                else {\n                    castErr.path = index;\n                }\n\n                castErr.message = `${castErr.message}(${castErr.path})`;\n                throw castErr;\n            }\n\n            obj._inner.ordereds.push(type);\n        });\n\n        return obj;\n    }\n\n    min(limit) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n\n        return this._testUnique('min', limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n                    return this.createError('array.ref', { ref: limit, value: compareTo }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (value.length >= compareTo) {\n                return value;\n            }\n\n            return this.createError('array.min', { limit, value }, state, options);\n        });\n    }\n\n    max(limit) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n\n        return this._testUnique('max', limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n                    return this.createError('array.ref', { ref: limit.key }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (value.length <= compareTo) {\n                return value;\n            }\n\n            return this.createError('array.max', { limit, value }, state, options);\n        });\n    }\n\n    length(limit) {\n\n        const isRef = Ref.isRef(limit);\n\n        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');\n\n        return this._testUnique('length', limit, function (value, state, options) {\n\n            let compareTo;\n            if (isRef) {\n                compareTo = limit(state.reference || state.parent, options);\n\n                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {\n                    return this.createError('array.ref', { ref: limit.key }, state, options);\n                }\n            }\n            else {\n                compareTo = limit;\n            }\n\n            if (value.length === compareTo) {\n                return value;\n            }\n\n            return this.createError('array.length', { limit, value }, state, options);\n        });\n    }\n\n    has(schema) {\n\n        try {\n            schema = Cast.schema(this._currentJoi, schema);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.message = `${castErr.message}(${castErr.path})`;\n            }\n\n            throw castErr;\n        }\n\n        return this._test('has', schema, function (value, state, options) {\n\n            const isValid = value.some((item, idx) => {\n\n                const localState = new State(idx, [...state.path, idx], state.key, state.reference);\n                return !schema._validate(item, localState, options).errors;\n            });\n\n            if (isValid) {\n                return value;\n            }\n\n            const patternLabel = schema._getLabel();\n            if (patternLabel) {\n                return this.createError('array.hasKnown', { patternLabel }, state, options);\n            }\n\n            return this.createError('array.hasUnknown', null, state, options);\n        });\n    }\n\n    unique(comparator, configs) {\n\n        Hoek.assert(comparator === undefined ||\n            typeof comparator === 'function' ||\n            typeof comparator === 'string', 'comparator must be a function or a string');\n\n        Hoek.assert(configs === undefined ||\n            typeof configs === 'object', 'configs must be an object');\n\n        const settings = {\n            ignoreUndefined: (configs && configs.ignoreUndefined) || false\n        };\n\n\n        if (typeof comparator === 'string') {\n            settings.path = comparator;\n        }\n        else if (typeof comparator === 'function') {\n            settings.comparator = comparator;\n        }\n\n        return this._test('unique', settings, function (value, state, options) {\n\n            const found = {\n                string: Object.create(null),\n                number: Object.create(null),\n                undefined: Object.create(null),\n                boolean: Object.create(null),\n                object: new Map(),\n                function: new Map(),\n                custom: new Map()\n            };\n\n            const compare = settings.comparator || Hoek.deepEqual;\n            const ignoreUndefined = settings.ignoreUndefined;\n\n            for (let i = 0; i < value.length; ++i) {\n                const item = settings.path ? Hoek.reach(value[i], settings.path) : value[i];\n                const records = settings.comparator ? found.custom : found[typeof item];\n\n                // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.\n                // I still want to keep the test for future js versions with new types (eg. Symbol).\n                if (/* $lab:coverage:off$ */ records /* $lab:coverage:on$ */) {\n                    if (records instanceof Map) {\n                        const entries = records.entries();\n                        let current;\n                        while (!(current = entries.next()).done) {\n                            if (compare(current.value[0], item)) {\n                                const localState = new State(state.key, [...state.path, i], state.parent, state.reference);\n                                const context = {\n                                    pos: i,\n                                    value: value[i],\n                                    dupePos: current.value[1],\n                                    dupeValue: value[current.value[1]]\n                                };\n\n                                if (settings.path) {\n                                    context.path = settings.path;\n                                }\n\n                                return this.createError('array.unique', context, localState, options);\n                            }\n                        }\n\n                        records.set(item, i);\n                    }\n                    else {\n                        if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {\n                            const localState = new State(state.key, [...state.path, i], state.parent, state.reference);\n\n                            const context = {\n                                pos: i,\n                                value: value[i],\n                                dupePos: records[item],\n                                dupeValue: value[records[item]]\n                            };\n\n                            if (settings.path) {\n                                context.path = settings.path;\n                            }\n\n                            return this.createError('array.unique', context, localState, options);\n                        }\n\n                        records[item] = i;\n                    }\n                }\n            }\n\n            return value;\n        });\n    }\n\n    sparse(enabled) {\n\n        const value = enabled === undefined ? true : !!enabled;\n\n        if (this._flags.sparse === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.sparse = value;\n        return obj;\n    }\n\n    single(enabled) {\n\n        const value = enabled === undefined ? true : !!enabled;\n\n        if (this._flags.single === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.single = value;\n        return obj;\n    }\n\n    _fillMissedErrors(errors, requireds, state, options) {\n\n        const knownMisses = [];\n        let unknownMisses = 0;\n        for (let i = 0; i < requireds.length; ++i) {\n            const label = requireds[i]._getLabel();\n            if (label) {\n                knownMisses.push(label);\n            }\n            else {\n                ++unknownMisses;\n            }\n        }\n\n        if (knownMisses.length) {\n            if (unknownMisses) {\n                errors.push(this.createError('array.includesRequiredBoth', { knownMisses, unknownMisses }, { key: state.key, path: state.path }, options));\n            }\n            else {\n                errors.push(this.createError('array.includesRequiredKnowns', { knownMisses }, { key: state.key, path: state.path }, options));\n            }\n        }\n        else {\n            errors.push(this.createError('array.includesRequiredUnknowns', { unknownMisses }, { key: state.key, path: state.path }, options));\n        }\n    }\n\n\n    _fillOrderedErrors(errors, ordereds, state, options) {\n\n        const requiredOrdereds = [];\n\n        for (let i = 0; i < ordereds.length; ++i) {\n            const presence = Hoek.reach(ordereds[i], '_flags.presence');\n            if (presence === 'required') {\n                requiredOrdereds.push(ordereds[i]);\n            }\n        }\n\n        if (requiredOrdereds.length) {\n            this._fillMissedErrors(errors, requiredOrdereds, state, options);\n        }\n    }\n\n};\n\n\ninternals.safeParse = function (value, result) {\n\n    try {\n        const converted = JSON.parse(value);\n        if (Array.isArray(converted)) {\n            result.value = converted;\n        }\n    }\n    catch (e) { }\n};\n\n\nmodule.exports = new internals.Array();\n"]},"metadata":{},"sourceType":"script"}