{"ast":null,"code":"'use strict'; // Load modules\n// Declare internals\n\nconst internals = {\n  arrayType: Symbol('array'),\n  bufferType: Symbol('buffer'),\n  dateType: Symbol('date'),\n  errorType: Symbol('error'),\n  genericType: Symbol('generic'),\n  mapType: Symbol('map'),\n  regexType: Symbol('regex'),\n  setType: Symbol('set'),\n  weakMapType: Symbol('weak-map'),\n  weakSetType: Symbol('weak-set'),\n  mismatched: Symbol('mismatched')\n};\ninternals.typeMap = {\n  '[object Array]': internals.arrayType,\n  '[object Date]': internals.dateType,\n  '[object Error]': internals.errorType,\n  '[object Map]': internals.mapType,\n  '[object RegExp]': internals.regexType,\n  '[object Set]': internals.setType,\n  '[object WeakMap]': internals.weakMapType,\n  '[object WeakSet]': internals.weakSetType\n};\ninternals.SeenEntry = class {\n  constructor(obj, ref) {\n    this.obj = obj;\n    this.ref = ref;\n  }\n\n  isSame(obj, ref) {\n    return this.obj === obj && this.ref === ref;\n  }\n\n};\n\ninternals.getInternalType = function (obj) {\n  const {\n    typeMap,\n    bufferType,\n    genericType\n  } = internals;\n\n  if (obj instanceof Buffer) {\n    return bufferType;\n  }\n\n  const objName = Object.prototype.toString.call(obj);\n  return typeMap[objName] || genericType;\n};\n\ninternals.getSharedType = function (obj, ref, checkPrototype) {\n  if (checkPrototype) {\n    if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {\n      return internals.mismatched;\n    }\n\n    return internals.getInternalType(obj);\n  }\n\n  const type = internals.getInternalType(obj);\n\n  if (type !== internals.getInternalType(ref)) {\n    return internals.mismatched;\n  }\n\n  return type;\n};\n\ninternals.valueOf = function (obj) {\n  const objValueOf = obj.valueOf;\n\n  if (objValueOf === undefined) {\n    return obj;\n  }\n\n  try {\n    return objValueOf.call(obj);\n  } catch (err) {\n    return err;\n  }\n};\n\ninternals.hasOwnEnumerableProperty = function (obj, key) {\n  return Object.prototype.propertyIsEnumerable.call(obj, key);\n};\n\ninternals.isSetSimpleEqual = function (obj, ref) {\n  for (const entry of obj) {\n    if (!ref.has(entry)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\ninternals.isDeepEqualObj = function (instanceType, obj, ref, options, seen) {\n  const {\n    isDeepEqual,\n    valueOf,\n    hasOwnEnumerableProperty\n  } = internals;\n  const {\n    keys,\n    getOwnPropertySymbols\n  } = Object;\n\n  if (instanceType === internals.arrayType) {\n    if (options.part) {\n      // Check if any index match any other index\n      for (let i = 0; i < obj.length; ++i) {\n        const objValue = obj[i];\n\n        for (let j = 0; j < ref.length; ++j) {\n          if (isDeepEqual(objValue, ref[j], options, seen)) {\n            return true;\n          }\n        }\n      }\n    } else {\n      if (obj.length !== ref.length) {\n        return false;\n      }\n\n      for (let i = 0; i < obj.length; ++i) {\n        if (!isDeepEqual(obj[i], ref[i], options, seen)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  } else if (instanceType === internals.setType) {\n    if (obj.size !== ref.size) {\n      return false;\n    }\n\n    if (!internals.isSetSimpleEqual(obj, ref)) {\n      // Check for deep equality\n      const ref2 = new Set(ref);\n\n      for (const objEntry of obj) {\n        if (ref2.delete(objEntry)) {\n          continue;\n        }\n\n        let found = false;\n\n        for (const refEntry of ref2) {\n          if (isDeepEqual(objEntry, refEntry, options, seen)) {\n            ref2.delete(refEntry);\n            found = true;\n            break;\n          }\n        }\n\n        if (!found) {\n          return false;\n        }\n      }\n    }\n  } else if (instanceType === internals.mapType) {\n    if (obj.size !== ref.size) {\n      return false;\n    }\n\n    for (const [key, value] of obj) {\n      if (value === undefined && !ref.has(key)) {\n        return false;\n      }\n\n      if (!isDeepEqual(value, ref.get(key), options, seen)) {\n        return false;\n      }\n    }\n  } else if (instanceType === internals.errorType) {\n    // Always check name and message\n    if (obj.name !== ref.name || obj.message !== ref.message) {\n      return false;\n    }\n  } // Check .valueOf()\n\n\n  const valueOfObj = valueOf(obj);\n  const valueOfRef = valueOf(ref);\n\n  if (!(obj === valueOfObj && ref === valueOfRef) && !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {\n    return false;\n  } // Check properties\n\n\n  const objKeys = keys(obj);\n\n  if (!options.part && objKeys.length !== keys(ref).length) {\n    return false;\n  }\n\n  for (let i = 0; i < objKeys.length; ++i) {\n    const key = objKeys[i];\n\n    if (!hasOwnEnumerableProperty(ref, key)) {\n      return false;\n    }\n\n    if (!isDeepEqual(obj[key], ref[key], options, seen)) {\n      return false;\n    }\n  } // Check symbols\n\n\n  if (options.symbols) {\n    const objSymbols = getOwnPropertySymbols(obj);\n    const refSymbols = new Set(getOwnPropertySymbols(ref));\n\n    for (let i = 0; i < objSymbols.length; ++i) {\n      const key = objSymbols[i];\n\n      if (hasOwnEnumerableProperty(obj, key)) {\n        if (!hasOwnEnumerableProperty(ref, key)) {\n          return false;\n        }\n\n        if (!isDeepEqual(obj[key], ref[key], options, seen)) {\n          return false;\n        }\n      } else if (hasOwnEnumerableProperty(ref, key)) {\n        return false;\n      }\n\n      refSymbols.delete(key);\n    }\n\n    for (const key of refSymbols) {\n      if (hasOwnEnumerableProperty(ref, key)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n\ninternals.isDeepEqual = function (obj, ref, options, seen) {\n  if (obj === ref) {\n    // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql\n    return obj !== 0 || 1 / obj === 1 / ref;\n  }\n\n  const type = typeof obj;\n\n  if (type !== typeof ref) {\n    return false;\n  }\n\n  if (type !== 'object' || obj === null || ref === null) {\n    return obj !== obj && ref !== ref; // NaN\n  }\n\n  const instanceType = internals.getSharedType(obj, ref, !!options.prototype);\n\n  switch (instanceType) {\n    case internals.bufferType:\n      return Buffer.prototype.equals.call(obj, ref);\n\n    case internals.regexType:\n      return obj.toString() === ref.toString();\n\n    case internals.mismatched:\n      return false;\n  }\n\n  for (let i = seen.length - 1; i >= 0; --i) {\n    if (seen[i].isSame(obj, ref)) {\n      return true; // If previous comparison failed, it would have stopped execution\n    }\n  }\n\n  seen.push(new internals.SeenEntry(obj, ref));\n\n  try {\n    return !!internals.isDeepEqualObj(instanceType, obj, ref, options, seen);\n  } finally {\n    seen.pop();\n  }\n};\n\nmodule.exports = function (obj, ref, options) {\n  options = options || {\n    prototype: true\n  };\n  return !!internals.isDeepEqual(obj, ref, options, []);\n};","map":{"version":3,"sources":["C:/vidly/vidly/node_modules/hoek/lib/deep-equal.js"],"names":["internals","arrayType","Symbol","bufferType","dateType","errorType","genericType","mapType","regexType","setType","weakMapType","weakSetType","mismatched","typeMap","SeenEntry","constructor","obj","ref","isSame","getInternalType","Buffer","objName","Object","prototype","toString","call","getSharedType","checkPrototype","getPrototypeOf","type","valueOf","objValueOf","undefined","err","hasOwnEnumerableProperty","key","propertyIsEnumerable","isSetSimpleEqual","entry","has","isDeepEqualObj","instanceType","options","seen","isDeepEqual","keys","getOwnPropertySymbols","part","i","length","objValue","j","size","ref2","Set","objEntry","delete","found","refEntry","value","get","name","message","valueOfObj","valueOfRef","objKeys","symbols","objSymbols","refSymbols","equals","push","pop","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n// Load modules\n\n\n// Declare internals\n\nconst internals = {\n    arrayType: Symbol('array'),\n    bufferType: Symbol('buffer'),\n    dateType: Symbol('date'),\n    errorType: Symbol('error'),\n    genericType: Symbol('generic'),\n    mapType: Symbol('map'),\n    regexType: Symbol('regex'),\n    setType: Symbol('set'),\n    weakMapType: Symbol('weak-map'),\n    weakSetType: Symbol('weak-set'),\n    mismatched: Symbol('mismatched')\n};\n\n\ninternals.typeMap = {\n    '[object Array]': internals.arrayType,\n    '[object Date]': internals.dateType,\n    '[object Error]': internals.errorType,\n    '[object Map]': internals.mapType,\n    '[object RegExp]': internals.regexType,\n    '[object Set]': internals.setType,\n    '[object WeakMap]': internals.weakMapType,\n    '[object WeakSet]': internals.weakSetType\n};\n\n\ninternals.SeenEntry = class {\n\n    constructor(obj, ref) {\n\n        this.obj = obj;\n        this.ref = ref;\n    }\n\n    isSame(obj, ref) {\n\n        return this.obj === obj && this.ref === ref;\n    }\n};\n\n\ninternals.getInternalType = function (obj) {\n\n    const { typeMap, bufferType, genericType } = internals;\n\n    if (obj instanceof Buffer) {\n        return bufferType;\n    }\n\n    const objName = Object.prototype.toString.call(obj);\n    return typeMap[objName] || genericType;\n};\n\n\ninternals.getSharedType = function (obj, ref, checkPrototype) {\n\n    if (checkPrototype) {\n        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {\n            return internals.mismatched;\n        }\n\n        return internals.getInternalType(obj);\n    }\n\n    const type = internals.getInternalType(obj);\n    if (type !== internals.getInternalType(ref)) {\n        return internals.mismatched;\n    }\n\n    return type;\n};\n\n\ninternals.valueOf = function (obj) {\n\n    const objValueOf = obj.valueOf;\n    if (objValueOf === undefined) {\n        return obj;\n    }\n\n    try {\n        return objValueOf.call(obj);\n    }\n    catch (err) {\n        return err;\n    }\n};\n\n\ninternals.hasOwnEnumerableProperty = function (obj, key) {\n\n    return Object.prototype.propertyIsEnumerable.call(obj, key);\n};\n\n\ninternals.isSetSimpleEqual = function (obj, ref) {\n\n    for (const entry of obj) {\n        if (!ref.has(entry)) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n\ninternals.isDeepEqualObj = function (instanceType, obj, ref, options, seen) {\n\n    const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;\n    const { keys, getOwnPropertySymbols } = Object;\n\n    if (instanceType === internals.arrayType) {\n        if (options.part) {\n            // Check if any index match any other index\n\n            for (let i = 0; i < obj.length; ++i) {\n                const objValue = obj[i];\n                for (let j = 0; j < ref.length; ++j) {\n                    if (isDeepEqual(objValue, ref[j], options, seen)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        else {\n            if (obj.length !== ref.length) {\n                return false;\n            }\n\n            for (let i = 0; i < obj.length; ++i) {\n                if (!isDeepEqual(obj[i], ref[i], options, seen)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n    }\n    else if (instanceType === internals.setType) {\n        if (obj.size !== ref.size) {\n            return false;\n        }\n\n        if (!internals.isSetSimpleEqual(obj, ref)) {\n\n            // Check for deep equality\n\n            const ref2 = new Set(ref);\n            for (const objEntry of obj) {\n                if (ref2.delete(objEntry)) {\n                    continue;\n                }\n\n                let found = false;\n                for (const refEntry of ref2) {\n                    if (isDeepEqual(objEntry, refEntry, options, seen)) {\n                        ref2.delete(refEntry);\n                        found = true;\n                        break;\n                    }\n                }\n\n                if (!found) {\n                    return false;\n                }\n            }\n        }\n    }\n    else if (instanceType === internals.mapType) {\n        if (obj.size !== ref.size) {\n            return false;\n        }\n\n        for (const [key, value] of obj) {\n            if (value === undefined && !ref.has(key)) {\n                return false;\n            }\n\n            if (!isDeepEqual(value, ref.get(key), options, seen)) {\n                return false;\n            }\n        }\n    }\n    else if (instanceType === internals.errorType) {\n        // Always check name and message\n\n        if (obj.name !== ref.name || obj.message !== ref.message) {\n            return false;\n        }\n    }\n\n    // Check .valueOf()\n\n    const valueOfObj = valueOf(obj);\n    const valueOfRef = valueOf(ref);\n    if (!(obj === valueOfObj && ref === valueOfRef) &&\n        !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {\n        return false;\n    }\n\n    // Check properties\n\n    const objKeys = keys(obj);\n    if (!options.part && objKeys.length !== keys(ref).length) {\n        return false;\n    }\n\n    for (let i = 0; i < objKeys.length; ++i) {\n        const key = objKeys[i];\n\n        if (!hasOwnEnumerableProperty(ref, key)) {\n            return false;\n        }\n\n        if (!isDeepEqual(obj[key], ref[key], options, seen)) {\n            return false;\n        }\n    }\n\n    // Check symbols\n\n    if (options.symbols) {\n        const objSymbols = getOwnPropertySymbols(obj);\n        const refSymbols = new Set(getOwnPropertySymbols(ref));\n\n        for (let i = 0; i < objSymbols.length; ++i) {\n            const key = objSymbols[i];\n\n            if (hasOwnEnumerableProperty(obj, key)) {\n                if (!hasOwnEnumerableProperty(ref, key)) {\n                    return false;\n                }\n\n                if (!isDeepEqual(obj[key], ref[key], options, seen)) {\n                    return false;\n                }\n            }\n            else if (hasOwnEnumerableProperty(ref, key)) {\n                return false;\n            }\n\n            refSymbols.delete(key);\n        }\n\n        for (const key of refSymbols) {\n            if (hasOwnEnumerableProperty(ref, key)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n};\n\n\ninternals.isDeepEqual = function (obj, ref, options, seen) {\n\n    if (obj === ref) {                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql\n        return obj !== 0 || 1 / obj === 1 / ref;\n    }\n\n    const type = typeof obj;\n\n    if (type !== typeof ref) {\n        return false;\n    }\n\n    if (type !== 'object' ||\n        obj === null ||\n        ref === null) {\n\n        return obj !== obj && ref !== ref;                  // NaN\n    }\n\n    const instanceType = internals.getSharedType(obj, ref, !!options.prototype);\n    switch (instanceType) {\n        case internals.bufferType:\n            return Buffer.prototype.equals.call(obj, ref);\n        case internals.regexType:\n            return obj.toString() === ref.toString();\n        case internals.mismatched:\n            return false;\n    }\n\n    for (let i = seen.length - 1; i >= 0; --i) {\n        if (seen[i].isSame(obj, ref)) {\n            return true;                                    // If previous comparison failed, it would have stopped execution\n        }\n    }\n\n    seen.push(new internals.SeenEntry(obj, ref));\n    try {\n        return !!internals.isDeepEqualObj(instanceType, obj, ref, options, seen);\n    }\n    finally {\n        seen.pop();\n    }\n};\n\n\nmodule.exports = function (obj, ref, options) {\n\n    options = options || { prototype: true };\n\n    return !!internals.isDeepEqual(obj, ref, options, []);\n};\n"]},"metadata":{},"sourceType":"script"}