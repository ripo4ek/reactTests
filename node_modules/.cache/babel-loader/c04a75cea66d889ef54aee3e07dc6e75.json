{"ast":null,"code":"'use strict'; // Load modules\n\nconst Assert = require('assert');\n\nconst Crypto = require('crypto');\n\nconst Path = require('path');\n\nconst DeepEqual = require('./deep-equal');\n\nconst Escape = require('./escape'); // Declare internals\n\n\nconst internals = {}; // Deep object or array comparison\n\nexports.deepEqual = DeepEqual; // Clone object or array\n\nexports.clone = function (obj, options = {}, _seen = null) {\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  const seen = _seen || new Map();\n  const lookup = seen.get(obj);\n\n  if (lookup) {\n    return lookup;\n  }\n\n  let newObj;\n  let cloneDeep = false;\n  const isArray = Array.isArray(obj);\n\n  if (!isArray) {\n    if (Buffer.isBuffer(obj)) {\n      newObj = Buffer.from(obj);\n    } else if (obj instanceof Date) {\n      newObj = new Date(obj.getTime());\n    } else if (obj instanceof RegExp) {\n      newObj = new RegExp(obj);\n    } else {\n      if (options.prototype !== false) {\n        // Defaults to true\n        const proto = Object.getPrototypeOf(obj);\n\n        if (proto && proto.isImmutable) {\n          newObj = obj;\n        } else {\n          newObj = Object.create(proto);\n          cloneDeep = true;\n        }\n      } else {\n        newObj = {};\n        cloneDeep = true;\n      }\n    }\n  } else {\n    newObj = [];\n    cloneDeep = true;\n  }\n\n  seen.set(obj, newObj);\n\n  if (cloneDeep) {\n    const keys = internals.keys(obj, options);\n\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n\n      if (isArray && key === 'length') {\n        continue;\n      }\n\n      const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\n      if (descriptor && (descriptor.get || descriptor.set)) {\n        Object.defineProperty(newObj, key, descriptor);\n      } else {\n        Object.defineProperty(newObj, key, {\n          enumerable: descriptor ? descriptor.enumerable : true,\n          writable: true,\n          configurable: true,\n          value: exports.clone(obj[key], options, seen)\n        });\n      }\n    }\n\n    if (isArray) {\n      newObj.length = obj.length;\n    }\n  }\n\n  return newObj;\n};\n\ninternals.keys = function (obj, options = {}) {\n  return options.symbols ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);\n}; // Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied\n\n\nexports.merge = function (target, source, isNullOverride\n/* = true */\n, isMergeArrays\n/* = true */\n) {\n  exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');\n  exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');\n\n  if (!source) {\n    return target;\n  }\n\n  if (Array.isArray(source)) {\n    exports.assert(Array.isArray(target), 'Cannot merge array onto an object');\n\n    if (isMergeArrays === false) {\n      // isMergeArrays defaults to true\n      target.length = 0; // Must not change target assignment\n    }\n\n    for (let i = 0; i < source.length; ++i) {\n      target.push(exports.clone(source[i]));\n    }\n\n    return target;\n  }\n\n  const keys = internals.keys(source);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (key === '__proto__' || !Object.prototype.propertyIsEnumerable.call(source, key)) {\n      continue;\n    }\n\n    const value = source[key];\n\n    if (value && typeof value === 'object') {\n      if (!target[key] || typeof target[key] !== 'object' || Array.isArray(target[key]) !== Array.isArray(value) || value instanceof Date || Buffer.isBuffer(value) || value instanceof RegExp) {\n        target[key] = exports.clone(value);\n      } else {\n        exports.merge(target[key], value, isNullOverride, isMergeArrays);\n      }\n    } else {\n      if (value !== null && value !== undefined) {\n        // Explicit to preserve empty strings\n        target[key] = value;\n      } else if (isNullOverride !== false) {\n        // Defaults to true\n        target[key] = value;\n      }\n    }\n  }\n\n  return target;\n}; // Apply options to a copy of the defaults\n\n\nexports.applyToDefaults = function (defaults, options, isNullOverride) {\n  exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n  exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n\n  if (!options) {\n    // If no options, return null\n    return null;\n  }\n\n  const copy = exports.clone(defaults);\n\n  if (options === true) {\n    // If options is set to true, use defaults\n    return copy;\n  }\n\n  return exports.merge(copy, options, isNullOverride === true, false);\n}; // Clone an object except for the listed keys which are shallow copied\n\n\nexports.cloneWithShallow = function (source, keys, options) {\n  if (!source || typeof source !== 'object') {\n    return source;\n  }\n\n  const storage = internals.store(source, keys); // Move shallow copy items to storage\n\n  const copy = exports.clone(source, options); // Deep copy the rest\n\n  internals.restore(copy, source, storage); // Shallow copy the stored items and restore\n\n  return copy;\n};\n\ninternals.store = function (source, keys) {\n  const storage = new Map();\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    const value = exports.reach(source, key);\n\n    if (typeof value === 'object' || typeof value === 'function') {\n      storage.set(key, value);\n      internals.reachSet(source, key, undefined);\n    }\n  }\n\n  return storage;\n};\n\ninternals.restore = function (copy, source, storage) {\n  for (const [key, value] of storage) {\n    internals.reachSet(copy, key, value);\n    internals.reachSet(source, key, value);\n  }\n};\n\ninternals.reachSet = function (obj, key, value) {\n  const path = Array.isArray(key) ? key : key.split('.');\n  let ref = obj;\n\n  for (let i = 0; i < path.length; ++i) {\n    const segment = path[i];\n\n    if (i + 1 === path.length) {\n      ref[segment] = value;\n    }\n\n    ref = ref[segment];\n  }\n}; // Apply options to defaults except for the listed keys which are shallow copied from option without merging\n\n\nexports.applyToDefaultsWithShallow = function (defaults, options, keys) {\n  exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n  exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n  exports.assert(keys && Array.isArray(keys), 'Invalid keys');\n\n  if (!options) {\n    // If no options, return null\n    return null;\n  }\n\n  const copy = exports.cloneWithShallow(defaults, keys);\n\n  if (options === true) {\n    // If options is set to true, use defaults\n    return copy;\n  }\n\n  const storage = internals.store(options, keys); // Move shallow copy items to storage\n\n  exports.merge(copy, options, false, false); // Deep copy the rest\n\n  internals.restore(copy, options, storage); // Shallow copy the stored items and restore\n\n  return copy;\n}; // Find the common unique items in two arrays\n\n\nexports.intersect = function (array1, array2, justFirst) {\n  if (!array1 || !array2) {\n    return justFirst ? null : [];\n  }\n\n  const common = [];\n  const hash = Array.isArray(array1) ? new Set(array1) : array1;\n  const found = new Set();\n\n  for (const value of array2) {\n    if (internals.has(hash, value) && !found.has(value)) {\n      if (justFirst) {\n        return value;\n      }\n\n      common.push(value);\n      found.add(value);\n    }\n  }\n\n  return justFirst ? null : common;\n};\n\ninternals.has = function (ref, key) {\n  if (typeof ref.has === 'function') {\n    return ref.has(key);\n  }\n\n  return ref[key] !== undefined;\n}; // Test if the reference contains the values\n\n\nexports.contain = function (ref, values, options = {}) {\n  // options: { deep, once, only, part, symbols }\n\n  /*\n      string -> string(s)\n      array -> item(s)\n      object -> key(s)\n      object -> object (key:value)\n  */\n  let valuePairs = null;\n\n  if (typeof ref === 'object' && typeof values === 'object' && !Array.isArray(ref) && !Array.isArray(values)) {\n    valuePairs = values;\n    const symbols = Object.getOwnPropertySymbols(values).filter(Object.prototype.propertyIsEnumerable.bind(values));\n    values = [...Object.keys(values), ...symbols];\n  } else {\n    values = [].concat(values);\n  }\n\n  exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');\n  exports.assert(values.length, 'Values array cannot be empty');\n  let compare;\n  let compareFlags;\n\n  if (options.deep) {\n    compare = exports.deepEqual;\n    const hasOnly = options.hasOwnProperty('only');\n    const hasPart = options.hasOwnProperty('part');\n    compareFlags = {\n      prototype: hasOnly ? options.only : hasPart ? !options.part : false,\n      part: hasOnly ? !options.only : hasPart ? options.part : false\n    };\n  } else {\n    compare = (a, b) => a === b;\n  }\n\n  let misses = false;\n  const matches = new Array(values.length);\n\n  for (let i = 0; i < matches.length; ++i) {\n    matches[i] = 0;\n  }\n\n  if (typeof ref === 'string') {\n    let pattern = '(';\n\n    for (let i = 0; i < values.length; ++i) {\n      const value = values[i];\n      exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');\n      pattern += (i ? '|' : '') + exports.escapeRegex(value);\n    }\n\n    const regex = new RegExp(pattern + ')', 'g');\n    const leftovers = ref.replace(regex, ($0, $1) => {\n      const index = values.indexOf($1);\n      ++matches[index];\n      return ''; // Remove from string\n    });\n    misses = !!leftovers;\n  } else if (Array.isArray(ref)) {\n    const onlyOnce = !!(options.only && options.once);\n\n    if (onlyOnce && ref.length !== values.length) {\n      return false;\n    }\n\n    for (let i = 0; i < ref.length; ++i) {\n      let matched = false;\n\n      for (let j = 0; j < values.length && matched === false; ++j) {\n        if (!onlyOnce || matches[j] === 0) {\n          matched = compare(values[j], ref[i], compareFlags) && j;\n        }\n      }\n\n      if (matched !== false) {\n        ++matches[matched];\n      } else {\n        misses = true;\n      }\n    }\n  } else {\n    const keys = internals.keys(ref, options);\n\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      const pos = values.indexOf(key);\n\n      if (pos !== -1) {\n        if (valuePairs && !compare(valuePairs[key], ref[key], compareFlags)) {\n          return false;\n        }\n\n        ++matches[pos];\n      } else {\n        misses = true;\n      }\n    }\n  }\n\n  if (options.only) {\n    if (misses || !options.once) {\n      return !misses;\n    }\n  }\n\n  let result = false;\n\n  for (let i = 0; i < matches.length; ++i) {\n    result = result || !!matches[i];\n\n    if (options.once && matches[i] > 1 || !options.part && !matches[i]) {\n      return false;\n    }\n  }\n\n  return result;\n}; // Flatten array\n\n\nexports.flatten = function (array, target) {\n  const result = target || [];\n\n  for (let i = 0; i < array.length; ++i) {\n    if (Array.isArray(array[i])) {\n      exports.flatten(array[i], result);\n    } else {\n      result.push(array[i]);\n    }\n  }\n\n  return result;\n}; // Convert an object key chain string ('a.b.c') to reference (object[a][b][c])\n\n\nexports.reach = function (obj, chain, options) {\n  if (chain === false || chain === null || typeof chain === 'undefined') {\n    return obj;\n  }\n\n  options = options || {};\n\n  if (typeof options === 'string') {\n    options = {\n      separator: options\n    };\n  }\n\n  const isChainArray = Array.isArray(chain);\n  exports.assert(!isChainArray || !options.separator, 'Separator option no valid for array-based chain');\n  const path = isChainArray ? chain : chain.split(options.separator || '.');\n  let ref = obj;\n\n  for (let i = 0; i < path.length; ++i) {\n    let key = path[i];\n\n    if (Array.isArray(ref)) {\n      const number = Number(key);\n\n      if (Number.isInteger(number) && number < 0) {\n        key = ref.length + number;\n      }\n    }\n\n    if (!ref || !((typeof ref === 'object' || typeof ref === 'function') && key in ref) || typeof ref !== 'object' && options.functions === false) {\n      // Only object and function can have properties\n      exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);\n      exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);\n      ref = options.default;\n      break;\n    }\n\n    ref = ref[key];\n  }\n\n  return ref;\n};\n\nexports.reachTemplate = function (obj, template, options) {\n  return template.replace(/{([^}]+)}/g, ($0, chain) => {\n    const value = exports.reach(obj, chain, options);\n    return value === undefined || value === null ? '' : value;\n  });\n};\n\nexports.assert = function (condition, ...args) {\n  if (condition) {\n    return;\n  }\n\n  if (args.length === 1 && args[0] instanceof Error) {\n    throw args[0];\n  }\n\n  const msgs = args.filter(arg => arg !== '').map(arg => {\n    return typeof arg === 'string' ? arg : arg instanceof Error ? arg.message : exports.stringify(arg);\n  });\n  throw new Assert.AssertionError({\n    message: msgs.join(' ') || 'Unknown error',\n    actual: false,\n    expected: true,\n    operator: '==',\n    stackStartFunction: exports.assert\n  });\n};\n\nexports.Bench = function () {\n  this.ts = 0;\n  this.reset();\n};\n\nexports.Bench.prototype.reset = function () {\n  this.ts = exports.Bench.now();\n};\n\nexports.Bench.prototype.elapsed = function () {\n  return exports.Bench.now() - this.ts;\n};\n\nexports.Bench.now = function () {\n  const ts = process.hrtime();\n  return ts[0] * 1e3 + ts[1] / 1e6;\n}; // Escape string for Regex construction\n\n\nexports.escapeRegex = function (string) {\n  // Escape ^$.*+-?=!:|\\/()[]{},\n  return string.replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&');\n}; // Escape attribute value for use in HTTP header\n\n\nexports.escapeHeaderAttribute = function (attribute) {\n  // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \\, \"\n  exports.assert(/^[ \\w\\!#\\$%&'\\(\\)\\*\\+,\\-\\.\\/\\:;<\\=>\\?@\\[\\]\\^`\\{\\|\\}~\\\"\\\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');\n  return attribute.replace(/\\\\/g, '\\\\\\\\').replace(/\\\"/g, '\\\\\"'); // Escape quotes and slash\n};\n\nexports.escapeHtml = function (string) {\n  return Escape.escapeHtml(string);\n};\n\nexports.escapeJson = function (string) {\n  return Escape.escapeJson(string);\n};\n\nexports.once = function (method) {\n  if (method._hoekOnce) {\n    return method;\n  }\n\n  let once = false;\n\n  const wrapped = function (...args) {\n    if (!once) {\n      once = true;\n      method(...args);\n    }\n  };\n\n  wrapped._hoekOnce = true;\n  return wrapped;\n};\n\nexports.ignore = function () {};\n\nexports.uniqueFilename = function (path, extension) {\n  if (extension) {\n    extension = extension[0] !== '.' ? '.' + extension : extension;\n  } else {\n    extension = '';\n  }\n\n  path = Path.resolve(path);\n  const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;\n  return Path.join(path, name);\n};\n\nexports.stringify = function (...args) {\n  try {\n    return JSON.stringify.apply(null, args);\n  } catch (err) {\n    return '[Cannot display object: ' + err.message + ']';\n  }\n};\n\nexports.wait = function (timeout) {\n  return new Promise(resolve => setTimeout(resolve, timeout));\n};\n\nexports.block = function () {\n  return new Promise(exports.ignore);\n};","map":{"version":3,"sources":["C:/vidly/vidly/node_modules/hoek/lib/index.js"],"names":["Assert","require","Crypto","Path","DeepEqual","Escape","internals","exports","deepEqual","clone","obj","options","_seen","seen","Map","lookup","get","newObj","cloneDeep","isArray","Array","Buffer","isBuffer","from","Date","getTime","RegExp","prototype","proto","Object","getPrototypeOf","isImmutable","create","set","keys","i","length","key","descriptor","getOwnPropertyDescriptor","defineProperty","enumerable","writable","configurable","value","symbols","Reflect","ownKeys","getOwnPropertyNames","merge","target","source","isNullOverride","isMergeArrays","assert","undefined","push","propertyIsEnumerable","call","applyToDefaults","defaults","copy","cloneWithShallow","storage","store","restore","reach","reachSet","path","split","ref","segment","applyToDefaultsWithShallow","intersect","array1","array2","justFirst","common","hash","Set","found","has","add","contain","values","valuePairs","getOwnPropertySymbols","filter","bind","concat","compare","compareFlags","deep","hasOnly","hasOwnProperty","hasPart","only","part","a","b","misses","matches","pattern","escapeRegex","regex","leftovers","replace","$0","$1","index","indexOf","onlyOnce","once","matched","j","pos","result","flatten","array","chain","separator","isChainArray","number","Number","isInteger","functions","strict","default","reachTemplate","template","condition","args","Error","msgs","arg","map","message","stringify","AssertionError","join","actual","expected","operator","stackStartFunction","Bench","ts","reset","now","elapsed","process","hrtime","string","escapeHeaderAttribute","attribute","test","escapeHtml","escapeJson","method","_hoekOnce","wrapped","ignore","uniqueFilename","extension","resolve","name","pid","randomBytes","toString","JSON","apply","err","wait","timeout","Promise","setTimeout","block"],"mappings":"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","sourcesContent":["'use strict';\n\n// Load modules\n\nconst Assert = require('assert');\nconst Crypto = require('crypto');\nconst Path = require('path');\n\nconst DeepEqual = require('./deep-equal');\nconst Escape = require('./escape');\n\n\n// Declare internals\n\nconst internals = {};\n\n\n// Deep object or array comparison\n\nexports.deepEqual = DeepEqual;\n\n\n// Clone object or array\n\nexports.clone = function (obj, options = {}, _seen = null) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    const seen = _seen || new Map();\n\n    const lookup = seen.get(obj);\n    if (lookup) {\n        return lookup;\n    }\n\n    let newObj;\n    let cloneDeep = false;\n    const isArray = Array.isArray(obj);\n\n    if (!isArray) {\n        if (Buffer.isBuffer(obj)) {\n            newObj = Buffer.from(obj);\n        }\n        else if (obj instanceof Date) {\n            newObj = new Date(obj.getTime());\n        }\n        else if (obj instanceof RegExp) {\n            newObj = new RegExp(obj);\n        }\n        else {\n            if (options.prototype !== false) {          // Defaults to true\n                const proto = Object.getPrototypeOf(obj);\n                if (proto &&\n                    proto.isImmutable) {\n\n                    newObj = obj;\n                }\n                else {\n                    newObj = Object.create(proto);\n                    cloneDeep = true;\n                }\n            }\n            else {\n                newObj = {};\n                cloneDeep = true;\n            }\n        }\n    }\n    else {\n        newObj = [];\n        cloneDeep = true;\n    }\n\n    seen.set(obj, newObj);\n\n    if (cloneDeep) {\n        const keys = internals.keys(obj, options);\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i];\n\n            if (isArray && key === 'length') {\n                continue;\n            }\n\n            const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n            if (descriptor &&\n                (descriptor.get ||\n                    descriptor.set)) {\n\n                Object.defineProperty(newObj, key, descriptor);\n            }\n            else {\n                Object.defineProperty(newObj, key, {\n                    enumerable: descriptor ? descriptor.enumerable : true,\n                    writable: true,\n                    configurable: true,\n                    value: exports.clone(obj[key], options, seen)\n                });\n            }\n        }\n\n        if (isArray) {\n            newObj.length = obj.length;\n        }\n    }\n\n    return newObj;\n};\n\n\ninternals.keys = function (obj, options = {}) {\n\n    return options.symbols ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);\n};\n\n\n// Merge all the properties of source into target, source wins in conflict, and by default null and undefined from source are applied\n\nexports.merge = function (target, source, isNullOverride /* = true */, isMergeArrays /* = true */) {\n\n    exports.assert(target && typeof target === 'object', 'Invalid target value: must be an object');\n    exports.assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');\n\n    if (!source) {\n        return target;\n    }\n\n    if (Array.isArray(source)) {\n        exports.assert(Array.isArray(target), 'Cannot merge array onto an object');\n        if (isMergeArrays === false) {                                                  // isMergeArrays defaults to true\n            target.length = 0;                                                          // Must not change target assignment\n        }\n\n        for (let i = 0; i < source.length; ++i) {\n            target.push(exports.clone(source[i]));\n        }\n\n        return target;\n    }\n\n    const keys = internals.keys(source);\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        if (key === '__proto__' ||\n            !Object.prototype.propertyIsEnumerable.call(source, key)) {\n\n            continue;\n        }\n\n        const value = source[key];\n        if (value &&\n            typeof value === 'object') {\n\n            if (!target[key] ||\n                typeof target[key] !== 'object' ||\n                (Array.isArray(target[key]) !== Array.isArray(value)) ||\n                value instanceof Date ||\n                Buffer.isBuffer(value) ||\n                value instanceof RegExp) {\n\n                target[key] = exports.clone(value);\n            }\n            else {\n                exports.merge(target[key], value, isNullOverride, isMergeArrays);\n            }\n        }\n        else {\n            if (value !== null &&\n                value !== undefined) {                              // Explicit to preserve empty strings\n\n                target[key] = value;\n            }\n            else if (isNullOverride !== false) {                    // Defaults to true\n                target[key] = value;\n            }\n        }\n    }\n\n    return target;\n};\n\n\n// Apply options to a copy of the defaults\n\nexports.applyToDefaults = function (defaults, options, isNullOverride) {\n\n    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n\n    if (!options) {                                                 // If no options, return null\n        return null;\n    }\n\n    const copy = exports.clone(defaults);\n\n    if (options === true) {                                         // If options is set to true, use defaults\n        return copy;\n    }\n\n    return exports.merge(copy, options, isNullOverride === true, false);\n};\n\n\n// Clone an object except for the listed keys which are shallow copied\n\nexports.cloneWithShallow = function (source, keys, options) {\n\n    if (!source ||\n        typeof source !== 'object') {\n\n        return source;\n    }\n\n    const storage = internals.store(source, keys);    // Move shallow copy items to storage\n    const copy = exports.clone(source, options);      // Deep copy the rest\n    internals.restore(copy, source, storage);         // Shallow copy the stored items and restore\n    return copy;\n};\n\n\ninternals.store = function (source, keys) {\n\n    const storage = new Map();\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const value = exports.reach(source, key);\n        if (typeof value === 'object' ||\n            typeof value === 'function') {\n\n            storage.set(key, value);\n            internals.reachSet(source, key, undefined);\n        }\n    }\n\n    return storage;\n};\n\n\ninternals.restore = function (copy, source, storage) {\n\n    for (const [key, value] of storage) {\n        internals.reachSet(copy, key, value);\n        internals.reachSet(source, key, value);\n    }\n};\n\n\ninternals.reachSet = function (obj, key, value) {\n\n    const path = Array.isArray(key) ? key : key.split('.');\n    let ref = obj;\n    for (let i = 0; i < path.length; ++i) {\n        const segment = path[i];\n        if (i + 1 === path.length) {\n            ref[segment] = value;\n        }\n\n        ref = ref[segment];\n    }\n};\n\n\n// Apply options to defaults except for the listed keys which are shallow copied from option without merging\n\nexports.applyToDefaultsWithShallow = function (defaults, options, keys) {\n\n    exports.assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');\n    exports.assert(!options || options === true || typeof options === 'object', 'Invalid options value: must be true, falsy or an object');\n    exports.assert(keys && Array.isArray(keys), 'Invalid keys');\n\n    if (!options) {                                                 // If no options, return null\n        return null;\n    }\n\n    const copy = exports.cloneWithShallow(defaults, keys);\n\n    if (options === true) {                                         // If options is set to true, use defaults\n        return copy;\n    }\n\n    const storage = internals.store(options, keys);     // Move shallow copy items to storage\n    exports.merge(copy, options, false, false);         // Deep copy the rest\n    internals.restore(copy, options, storage);          // Shallow copy the stored items and restore\n    return copy;\n};\n\n\n// Find the common unique items in two arrays\n\nexports.intersect = function (array1, array2, justFirst) {\n\n    if (!array1 ||\n        !array2) {\n\n        return (justFirst ? null : []);\n    }\n\n    const common = [];\n    const hash = (Array.isArray(array1) ? new Set(array1) : array1);\n    const found = new Set();\n    for (const value of array2) {\n        if (internals.has(hash, value) &&\n            !found.has(value)) {\n\n            if (justFirst) {\n                return value;\n            }\n\n            common.push(value);\n            found.add(value);\n        }\n    }\n\n    return (justFirst ? null : common);\n};\n\n\ninternals.has = function (ref, key) {\n\n    if (typeof ref.has === 'function') {\n        return ref.has(key);\n    }\n\n    return ref[key] !== undefined;\n};\n\n\n// Test if the reference contains the values\n\nexports.contain = function (ref, values, options = {}) {        // options: { deep, once, only, part, symbols }\n\n    /*\n        string -> string(s)\n        array -> item(s)\n        object -> key(s)\n        object -> object (key:value)\n    */\n\n    let valuePairs = null;\n    if (typeof ref === 'object' &&\n        typeof values === 'object' &&\n        !Array.isArray(ref) &&\n        !Array.isArray(values)) {\n\n        valuePairs = values;\n        const symbols = Object.getOwnPropertySymbols(values).filter(Object.prototype.propertyIsEnumerable.bind(values));\n        values = [...Object.keys(values), ...symbols];\n    }\n    else {\n        values = [].concat(values);\n    }\n\n    exports.assert(typeof ref === 'string' || typeof ref === 'object', 'Reference must be string or an object');\n    exports.assert(values.length, 'Values array cannot be empty');\n\n    let compare;\n    let compareFlags;\n    if (options.deep) {\n        compare = exports.deepEqual;\n\n        const hasOnly = options.hasOwnProperty('only');\n        const hasPart = options.hasOwnProperty('part');\n\n        compareFlags = {\n            prototype: hasOnly ? options.only : hasPart ? !options.part : false,\n            part: hasOnly ? !options.only : hasPart ? options.part : false\n        };\n    }\n    else {\n        compare = (a, b) => a === b;\n    }\n\n    let misses = false;\n    const matches = new Array(values.length);\n    for (let i = 0; i < matches.length; ++i) {\n        matches[i] = 0;\n    }\n\n    if (typeof ref === 'string') {\n        let pattern = '(';\n        for (let i = 0; i < values.length; ++i) {\n            const value = values[i];\n            exports.assert(typeof value === 'string', 'Cannot compare string reference to non-string value');\n            pattern += (i ? '|' : '') + exports.escapeRegex(value);\n        }\n\n        const regex = new RegExp(pattern + ')', 'g');\n        const leftovers = ref.replace(regex, ($0, $1) => {\n\n            const index = values.indexOf($1);\n            ++matches[index];\n            return '';          // Remove from string\n        });\n\n        misses = !!leftovers;\n    }\n    else if (Array.isArray(ref)) {\n        const onlyOnce = !!(options.only && options.once);\n        if (onlyOnce && ref.length !== values.length) {\n            return false;\n        }\n\n        for (let i = 0; i < ref.length; ++i) {\n            let matched = false;\n            for (let j = 0; j < values.length && matched === false; ++j) {\n                if (!onlyOnce || matches[j] === 0) {\n                    matched = compare(values[j], ref[i], compareFlags) && j;\n                }\n            }\n\n            if (matched !== false) {\n                ++matches[matched];\n            }\n            else {\n                misses = true;\n            }\n        }\n    }\n    else {\n        const keys = internals.keys(ref, options);\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i];\n            const pos = values.indexOf(key);\n            if (pos !== -1) {\n                if (valuePairs &&\n                    !compare(valuePairs[key], ref[key], compareFlags)) {\n\n                    return false;\n                }\n\n                ++matches[pos];\n            }\n            else {\n                misses = true;\n            }\n        }\n    }\n\n    if (options.only) {\n        if (misses || !options.once) {\n            return !misses;\n        }\n    }\n\n    let result = false;\n    for (let i = 0; i < matches.length; ++i) {\n        result = result || !!matches[i];\n        if ((options.once && matches[i] > 1) ||\n            (!options.part && !matches[i])) {\n\n            return false;\n        }\n    }\n\n    return result;\n};\n\n\n// Flatten array\n\nexports.flatten = function (array, target) {\n\n    const result = target || [];\n\n    for (let i = 0; i < array.length; ++i) {\n        if (Array.isArray(array[i])) {\n            exports.flatten(array[i], result);\n        }\n        else {\n            result.push(array[i]);\n        }\n    }\n\n    return result;\n};\n\n\n// Convert an object key chain string ('a.b.c') to reference (object[a][b][c])\n\nexports.reach = function (obj, chain, options) {\n\n    if (chain === false ||\n        chain === null ||\n        typeof chain === 'undefined') {\n\n        return obj;\n    }\n\n    options = options || {};\n    if (typeof options === 'string') {\n        options = { separator: options };\n    }\n\n    const isChainArray = Array.isArray(chain);\n\n    exports.assert(!isChainArray || !options.separator, 'Separator option no valid for array-based chain');\n\n    const path = isChainArray ? chain : chain.split(options.separator || '.');\n    let ref = obj;\n    for (let i = 0; i < path.length; ++i) {\n        let key = path[i];\n\n        if (Array.isArray(ref)) {\n            const number = Number(key);\n\n            if (Number.isInteger(number) && number < 0) {\n                key = ref.length + number;\n            }\n        }\n\n        if (!ref ||\n            !((typeof ref === 'object' || typeof ref === 'function') && key in ref) ||\n            (typeof ref !== 'object' && options.functions === false)) {         // Only object and function can have properties\n\n            exports.assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);\n            exports.assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);\n            ref = options.default;\n            break;\n        }\n\n        ref = ref[key];\n    }\n\n    return ref;\n};\n\n\nexports.reachTemplate = function (obj, template, options) {\n\n    return template.replace(/{([^}]+)}/g, ($0, chain) => {\n\n        const value = exports.reach(obj, chain, options);\n        return (value === undefined || value === null ? '' : value);\n    });\n};\n\n\nexports.assert = function (condition, ...args) {\n\n    if (condition) {\n        return;\n    }\n\n    if (args.length === 1 && args[0] instanceof Error) {\n        throw args[0];\n    }\n\n    const msgs = args\n        .filter((arg) => arg !== '')\n        .map((arg) => {\n\n            return typeof arg === 'string' ? arg : arg instanceof Error ? arg.message : exports.stringify(arg);\n        });\n\n    throw new Assert.AssertionError({\n        message: msgs.join(' ') || 'Unknown error',\n        actual: false,\n        expected: true,\n        operator: '==',\n        stackStartFunction: exports.assert\n    });\n};\n\n\nexports.Bench = function () {\n\n    this.ts = 0;\n    this.reset();\n};\n\n\nexports.Bench.prototype.reset = function () {\n\n    this.ts = exports.Bench.now();\n};\n\n\nexports.Bench.prototype.elapsed = function () {\n\n    return exports.Bench.now() - this.ts;\n};\n\n\nexports.Bench.now = function () {\n\n    const ts = process.hrtime();\n    return (ts[0] * 1e3) + (ts[1] / 1e6);\n};\n\n\n// Escape string for Regex construction\n\nexports.escapeRegex = function (string) {\n\n    // Escape ^$.*+-?=!:|\\/()[]{},\n    return string.replace(/[\\^\\$\\.\\*\\+\\-\\?\\=\\!\\:\\|\\\\\\/\\(\\)\\[\\]\\{\\}\\,]/g, '\\\\$&');\n};\n\n\n// Escape attribute value for use in HTTP header\n\nexports.escapeHeaderAttribute = function (attribute) {\n\n    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \\, \"\n\n    exports.assert(/^[ \\w\\!#\\$%&'\\(\\)\\*\\+,\\-\\.\\/\\:;<\\=>\\?@\\[\\]\\^`\\{\\|\\}~\\\"\\\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');\n\n    return attribute.replace(/\\\\/g, '\\\\\\\\').replace(/\\\"/g, '\\\\\"');                             // Escape quotes and slash\n};\n\n\nexports.escapeHtml = function (string) {\n\n    return Escape.escapeHtml(string);\n};\n\n\nexports.escapeJson = function (string) {\n\n    return Escape.escapeJson(string);\n};\n\n\nexports.once = function (method) {\n\n    if (method._hoekOnce) {\n        return method;\n    }\n\n    let once = false;\n    const wrapped = function (...args) {\n\n        if (!once) {\n            once = true;\n            method(...args);\n        }\n    };\n\n    wrapped._hoekOnce = true;\n    return wrapped;\n};\n\n\nexports.ignore = function () { };\n\n\nexports.uniqueFilename = function (path, extension) {\n\n    if (extension) {\n        extension = extension[0] !== '.' ? '.' + extension : extension;\n    }\n    else {\n        extension = '';\n    }\n\n    path = Path.resolve(path);\n    const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;\n    return Path.join(path, name);\n};\n\n\nexports.stringify = function (...args) {\n\n    try {\n        return JSON.stringify.apply(null, args);\n    }\n    catch (err) {\n        return '[Cannot display object: ' + err.message + ']';\n    }\n};\n\n\nexports.wait = function (timeout) {\n\n    return new Promise((resolve) => setTimeout(resolve, timeout));\n};\n\n\nexports.block = function () {\n\n    return new Promise(exports.ignore);\n};\n"]},"metadata":{},"sourceType":"script"}