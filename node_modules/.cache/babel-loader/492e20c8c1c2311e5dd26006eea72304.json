{"ast":null,"code":"'use strict'; // Load modules\n\nconst Hoek = require('hoek');\n\nconst Topo = require('topo');\n\nconst Any = require('../any');\n\nconst Errors = require('../../errors');\n\nconst Cast = require('../../cast');\n\nconst State = require('../state'); // Declare internals\n\n\nconst internals = {};\ninternals.Object = class extends Any {\n  constructor() {\n    super();\n    this._type = 'object';\n    this._inner.children = null;\n    this._inner.renames = [];\n    this._inner.dependencies = [];\n    this._inner.patterns = [];\n  }\n\n  _init(...args) {\n    return args.length ? this.keys(...args) : this;\n  }\n\n  _base(value, state, options) {\n    let target = value;\n    const errors = [];\n\n    const finish = () => {\n      return {\n        value: target,\n        errors: errors.length ? errors : null\n      };\n    };\n\n    if (typeof value === 'string' && options.convert) {\n      value = internals.safeParse(value);\n    }\n\n    const type = this._flags.func ? 'function' : 'object';\n\n    if (!value || typeof value !== type || Array.isArray(value)) {\n      errors.push(this.createError(type + '.base', {\n        value\n      }, state, options));\n      return finish();\n    } // Skip if there are no other rules to test\n\n\n    if (!this._inner.renames.length && !this._inner.dependencies.length && !this._inner.children && // null allows any keys\n    !this._inner.patterns.length) {\n      target = value;\n      return finish();\n    } // Ensure target is a local copy (parsed) or shallow copy\n\n\n    if (target === value) {\n      if (type === 'object') {\n        target = Object.create(Object.getPrototypeOf(value));\n      } else {\n        target = function (...args) {\n          return value.apply(this, args);\n        };\n\n        target.prototype = Hoek.clone(value.prototype);\n      }\n\n      const valueKeys = Object.keys(value);\n\n      for (let i = 0; i < valueKeys.length; ++i) {\n        target[valueKeys[i]] = value[valueKeys[i]];\n      }\n    } else {\n      target = value;\n    } // Rename keys\n\n\n    const renamed = {};\n\n    for (let i = 0; i < this._inner.renames.length; ++i) {\n      const rename = this._inner.renames[i];\n\n      if (rename.isRegExp) {\n        const targetKeys = Object.keys(target);\n        const matchedTargetKeys = [];\n\n        for (let j = 0; j < targetKeys.length; ++j) {\n          if (rename.from.test(targetKeys[j])) {\n            matchedTargetKeys.push(targetKeys[j]);\n          }\n        }\n\n        const allUndefined = matchedTargetKeys.every(key => target[key] === undefined);\n\n        if (rename.options.ignoreUndefined && allUndefined) {\n          continue;\n        }\n\n        if (!rename.options.multiple && renamed[rename.to]) {\n          errors.push(this.createError('object.rename.regex.multiple', {\n            from: matchedTargetKeys,\n            to: rename.to\n          }, state, options));\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n\n        if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {\n          errors.push(this.createError('object.rename.regex.override', {\n            from: matchedTargetKeys,\n            to: rename.to\n          }, state, options));\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n\n        if (allUndefined) {\n          delete target[rename.to];\n        } else {\n          target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\n        }\n\n        renamed[rename.to] = true;\n\n        if (!rename.options.alias) {\n          for (let j = 0; j < matchedTargetKeys.length; ++j) {\n            delete target[matchedTargetKeys[j]];\n          }\n        }\n      } else {\n        if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\n          continue;\n        }\n\n        if (!rename.options.multiple && renamed[rename.to]) {\n          errors.push(this.createError('object.rename.multiple', {\n            from: rename.from,\n            to: rename.to\n          }, state, options));\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n\n        if (Object.prototype.hasOwnProperty.call(target, rename.to) && !rename.options.override && !renamed[rename.to]) {\n          errors.push(this.createError('object.rename.override', {\n            from: rename.from,\n            to: rename.to\n          }, state, options));\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        }\n\n        if (target[rename.from] === undefined) {\n          delete target[rename.to];\n        } else {\n          target[rename.to] = target[rename.from];\n        }\n\n        renamed[rename.to] = true;\n\n        if (!rename.options.alias) {\n          delete target[rename.from];\n        }\n      }\n    } // Validate schema\n\n\n    if (!this._inner.children && // null allows any keys\n    !this._inner.patterns.length && !this._inner.dependencies.length) {\n      return finish();\n    }\n\n    const unprocessed = new Set(Object.keys(target));\n\n    if (this._inner.children) {\n      const stripProps = [];\n\n      for (let i = 0; i < this._inner.children.length; ++i) {\n        const child = this._inner.children[i];\n        const key = child.key;\n        const item = target[key];\n        unprocessed.delete(key);\n        const localState = new State(key, [...state.path, key], target, state.reference);\n\n        const result = child.schema._validate(item, localState, options);\n\n        if (result.errors) {\n          errors.push(this.createError('object.child', {\n            key,\n            child: child.schema._getLabel(key),\n            reason: result.errors\n          }, localState, options));\n\n          if (options.abortEarly) {\n            return finish();\n          }\n        } else {\n          if (child.schema._flags.strip || result.value === undefined && result.value !== item) {\n            stripProps.push(key);\n            target[key] = result.finalValue;\n          } else if (result.value !== undefined) {\n            target[key] = result.value;\n          }\n        }\n      }\n\n      for (let i = 0; i < stripProps.length; ++i) {\n        delete target[stripProps[i]];\n      }\n    } // Unknown keys\n\n\n    if (unprocessed.size && this._inner.patterns.length) {\n      for (const key of unprocessed) {\n        const localState = new State(key, [...state.path, key], target, state.reference);\n        const item = target[key];\n\n        for (let i = 0; i < this._inner.patterns.length; ++i) {\n          const pattern = this._inner.patterns[i];\n\n          if (pattern.regex ? pattern.regex.test(key) : !pattern.schema.validate(key).error) {\n            unprocessed.delete(key);\n\n            const result = pattern.rule._validate(item, localState, options);\n\n            if (result.errors) {\n              errors.push(this.createError('object.child', {\n                key,\n                child: pattern.rule._getLabel(key),\n                reason: result.errors\n              }, localState, options));\n\n              if (options.abortEarly) {\n                return finish();\n              }\n            }\n\n            target[key] = result.value;\n          }\n        }\n      }\n    }\n\n    if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\n      if (options.stripUnknown && this._flags.allowUnknown !== true || options.skipFunctions) {\n        const stripUnknown = options.stripUnknown ? options.stripUnknown === true ? true : !!options.stripUnknown.objects : false;\n\n        for (const key of unprocessed) {\n          if (stripUnknown) {\n            delete target[key];\n            unprocessed.delete(key);\n          } else if (typeof target[key] === 'function') {\n            unprocessed.delete(key);\n          }\n        }\n      }\n\n      if (this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown) {\n        for (const unprocessedKey of unprocessed) {\n          errors.push(this.createError('object.allowUnknown', {\n            child: unprocessedKey,\n            value: target[unprocessedKey]\n          }, {\n            key: unprocessedKey,\n            path: [...state.path, unprocessedKey]\n          }, options, {}));\n        }\n      }\n    } // Validate dependencies\n\n\n    for (let i = 0; i < this._inner.dependencies.length; ++i) {\n      const dep = this._inner.dependencies[i];\n      const hasKey = dep.key !== null;\n      const splitKey = hasKey && dep.key.split('.');\n      const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\n      const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key, {\n        functions: true\n      }), dep.peers, target, localState, options);\n\n      if (err instanceof Errors.Err) {\n        errors.push(err);\n\n        if (options.abortEarly) {\n          return finish();\n        }\n      }\n    }\n\n    return finish();\n  }\n\n  keys(schema) {\n    Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n    Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\n    const obj = this.clone();\n\n    if (!schema) {\n      obj._inner.children = null;\n      return obj;\n    }\n\n    const children = Object.keys(schema);\n\n    if (!children.length) {\n      obj._inner.children = [];\n      return obj;\n    }\n\n    const topo = new Topo();\n\n    if (obj._inner.children) {\n      for (let i = 0; i < obj._inner.children.length; ++i) {\n        const child = obj._inner.children[i]; // Only add the key if we are not going to replace it later\n\n        if (!children.includes(child.key)) {\n          topo.add(child, {\n            after: child._refs,\n            group: child.key\n          });\n        }\n      }\n    }\n\n    for (let i = 0; i < children.length; ++i) {\n      const key = children[i];\n      const child = schema[key];\n\n      try {\n        const cast = Cast.schema(this._currentJoi, child);\n        topo.add({\n          key,\n          schema: cast\n        }, {\n          after: cast._refs,\n          group: key\n        });\n      } catch (castErr) {\n        if (castErr.hasOwnProperty('path')) {\n          castErr.path = key + '.' + castErr.path;\n        } else {\n          castErr.path = key;\n        }\n\n        throw castErr;\n      }\n    }\n\n    obj._inner.children = topo.nodes;\n    return obj;\n  }\n\n  append(schema) {\n    // Skip any changes\n    if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\n      return this;\n    }\n\n    return this.keys(schema);\n  }\n\n  unknown(allow) {\n    const value = allow !== false;\n\n    if (this._flags.allowUnknown === value) {\n      return this;\n    }\n\n    const obj = this.clone();\n    obj._flags.allowUnknown = value;\n    return obj;\n  }\n\n  length(limit) {\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('length', limit, function (value, state, options) {\n      if (Object.keys(value).length === limit) {\n        return value;\n      }\n\n      return this.createError('object.length', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  min(limit) {\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('min', limit, function (value, state, options) {\n      if (Object.keys(value).length >= limit) {\n        return value;\n      }\n\n      return this.createError('object.min', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  max(limit) {\n    Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n    return this._test('max', limit, function (value, state, options) {\n      if (Object.keys(value).length <= limit) {\n        return value;\n      }\n\n      return this.createError('object.max', {\n        limit,\n        value\n      }, state, options);\n    });\n  }\n\n  pattern(pattern, schema) {\n    const isRegExp = pattern instanceof RegExp;\n    Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\n    Hoek.assert(schema !== undefined, 'Invalid rule');\n\n    if (isRegExp) {\n      Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n    }\n\n    try {\n      schema = Cast.schema(this._currentJoi, schema);\n    } catch (castErr) {\n      if (castErr.hasOwnProperty('path')) {\n        castErr.message = `${castErr.message}(${castErr.path})`;\n      }\n\n      throw castErr;\n    }\n\n    const obj = this.clone();\n\n    if (isRegExp) {\n      obj._inner.patterns.push({\n        regex: pattern,\n        rule: schema\n      });\n    } else {\n      obj._inner.patterns.push({\n        schema: pattern,\n        rule: schema\n      });\n    }\n\n    return obj;\n  }\n\n  schema() {\n    return this._test('schema', null, function (value, state, options) {\n      if (value instanceof Any) {\n        return value;\n      }\n\n      return this.createError('object.schema', null, state, options);\n    });\n  }\n\n  with(key, peers) {\n    Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n    return this._dependency('with', key, peers);\n  }\n\n  without(key, peers) {\n    Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n    return this._dependency('without', key, peers);\n  }\n\n  xor(...peers) {\n    peers = Hoek.flatten(peers);\n    return this._dependency('xor', null, peers);\n  }\n\n  oxor(...peers) {\n    return this._dependency('oxor', null, peers);\n  }\n\n  or(...peers) {\n    peers = Hoek.flatten(peers);\n    return this._dependency('or', null, peers);\n  }\n\n  and(...peers) {\n    peers = Hoek.flatten(peers);\n    return this._dependency('and', null, peers);\n  }\n\n  nand(...peers) {\n    peers = Hoek.flatten(peers);\n    return this._dependency('nand', null, peers);\n  }\n\n  requiredKeys(...children) {\n    children = Hoek.flatten(children);\n    return this.applyFunctionToChildren(children, 'required');\n  }\n\n  optionalKeys(...children) {\n    children = Hoek.flatten(children);\n    return this.applyFunctionToChildren(children, 'optional');\n  }\n\n  forbiddenKeys(...children) {\n    children = Hoek.flatten(children);\n    return this.applyFunctionToChildren(children, 'forbidden');\n  }\n\n  rename(from, to, options) {\n    Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n    Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n    Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n\n    for (let i = 0; i < this._inner.renames.length; ++i) {\n      Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n    }\n\n    const obj = this.clone();\n\n    obj._inner.renames.push({\n      from,\n      to,\n      options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\n      isRegExp: from instanceof RegExp\n    });\n\n    return obj;\n  }\n\n  applyFunctionToChildren(children, fn, args = [], root) {\n    children = [].concat(children);\n    Hoek.assert(children.length > 0, 'expected at least one children');\n    const groupedChildren = internals.groupChildren(children);\n    let obj;\n\n    if ('' in groupedChildren) {\n      obj = this[fn](...args);\n      delete groupedChildren[''];\n    } else {\n      obj = this.clone();\n    }\n\n    if (obj._inner.children) {\n      root = root ? root + '.' : '';\n\n      for (let i = 0; i < obj._inner.children.length; ++i) {\n        const child = obj._inner.children[i];\n        const group = groupedChildren[child.key];\n\n        if (group) {\n          obj._inner.children[i] = {\n            key: child.key,\n            _refs: child._refs,\n            schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n          };\n          delete groupedChildren[child.key];\n        }\n      }\n    }\n\n    const remaining = Object.keys(groupedChildren);\n    Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n    return obj;\n  }\n\n  _dependency(type, key, peers) {\n    peers = [].concat(peers);\n\n    for (let i = 0; i < peers.length; ++i) {\n      Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n    }\n\n    const obj = this.clone();\n\n    obj._inner.dependencies.push({\n      type,\n      key,\n      peers\n    });\n\n    return obj;\n  }\n\n  describe(shallow) {\n    const description = super.describe();\n\n    if (description.rules) {\n      for (let i = 0; i < description.rules.length; ++i) {\n        const rule = description.rules[i]; // Coverage off for future-proof descriptions, only object().assert() is use right now\n\n        if (\n        /* $lab:coverage:off$ */\n        rule.arg && typeof rule.arg === 'object' && rule.arg.schema && rule.arg.ref\n        /* $lab:coverage:on$ */\n        ) {\n            rule.arg = {\n              schema: rule.arg.schema.describe(),\n              ref: rule.arg.ref.toString()\n            };\n          }\n      }\n    }\n\n    if (this._inner.children && !shallow) {\n      description.children = {};\n\n      for (let i = 0; i < this._inner.children.length; ++i) {\n        const child = this._inner.children[i];\n        description.children[child.key] = child.schema.describe();\n      }\n    }\n\n    if (this._inner.dependencies.length) {\n      description.dependencies = Hoek.clone(this._inner.dependencies);\n    }\n\n    if (this._inner.patterns.length) {\n      description.patterns = [];\n\n      for (let i = 0; i < this._inner.patterns.length; ++i) {\n        const pattern = this._inner.patterns[i];\n\n        if (pattern.regex) {\n          description.patterns.push({\n            regex: pattern.regex.toString(),\n            rule: pattern.rule.describe()\n          });\n        } else {\n          description.patterns.push({\n            schema: pattern.schema.describe(),\n            rule: pattern.rule.describe()\n          });\n        }\n      }\n    }\n\n    if (this._inner.renames.length > 0) {\n      description.renames = Hoek.clone(this._inner.renames);\n    }\n\n    return description;\n  }\n\n  assert(ref, schema, message) {\n    ref = Cast.ref(ref);\n    Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n    message = message || 'pass the assertion test';\n    Hoek.assert(typeof message === 'string', 'Message must be a string');\n\n    try {\n      schema = Cast.schema(this._currentJoi, schema);\n    } catch (castErr) {\n      if (castErr.hasOwnProperty('path')) {\n        castErr.message = `${castErr.message}(${castErr.path})`;\n      }\n\n      throw castErr;\n    }\n\n    const key = ref.path[ref.path.length - 1];\n    const path = ref.path.join('.');\n    return this._test('assert', {\n      schema,\n      ref\n    }, function (value, state, options) {\n      const result = schema._validate(ref(value), null, options, value);\n\n      if (!result.errors) {\n        return value;\n      }\n\n      const localState = new State(key, ref.path, state.parent, state.reference);\n      return this.createError('object.assert', {\n        ref: path,\n        message\n      }, localState, options);\n    });\n  }\n\n  type(constructor, name = constructor.name) {\n    Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n    const typeData = {\n      name,\n      ctor: constructor\n    };\n    return this._test('type', typeData, function (value, state, options) {\n      if (value instanceof constructor) {\n        return value;\n      }\n\n      return this.createError('object.type', {\n        type: typeData.name,\n        value\n      }, state, options);\n    });\n  }\n\n};\n\ninternals.safeParse = function (value) {\n  try {\n    return JSON.parse(value);\n  } catch (parseErr) {}\n\n  return value;\n};\n\ninternals.renameDefaults = {\n  alias: false,\n  // Keep old value in place\n  multiple: false,\n  // Allow renaming multiple keys into the same target\n  override: false // Overrides an existing key\n\n};\n\ninternals.groupChildren = function (children) {\n  children.sort();\n  const grouped = {};\n\n  for (let i = 0; i < children.length; ++i) {\n    const child = children[i];\n    Hoek.assert(typeof child === 'string', 'children must be strings');\n    const group = child.split('.')[0];\n    const childGroup = grouped[group] = grouped[group] || [];\n    childGroup.push(child.substring(group.length + 1));\n  }\n\n  return grouped;\n};\n\ninternals.keysToLabels = function (schema, keys) {\n  const children = schema._inner.children;\n\n  if (!children) {\n    return keys;\n  }\n\n  const findLabel = function (key) {\n    const matchingChild = schema._currentJoi.reach(schema, key);\n\n    return matchingChild ? matchingChild._getLabel(key) : key;\n  };\n\n  if (Array.isArray(keys)) {\n    return keys.map(findLabel);\n  }\n\n  return findLabel(keys);\n};\n\ninternals.with = function (key, value, peers, parent, state, options) {\n  if (value === undefined) {\n    return;\n  }\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist === undefined) {\n      return this.createError('object.with', {\n        main: key,\n        mainWithLabel: internals.keysToLabels(this, key),\n        peer,\n        peerWithLabel: internals.keysToLabels(this, peer)\n      }, state, options);\n    }\n  }\n};\n\ninternals.without = function (key, value, peers, parent, state, options) {\n  if (value === undefined) {\n    return;\n  }\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      return this.createError('object.without', {\n        main: key,\n        mainWithLabel: internals.keysToLabels(this, key),\n        peer,\n        peerWithLabel: internals.keysToLabels(this, peer)\n      }, state, options);\n    }\n  }\n};\n\ninternals.xor = function (key, value, peers, parent, state, options) {\n  const present = [];\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  if (present.length === 1) {\n    return;\n  }\n\n  const context = {\n    peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  };\n\n  if (present.length === 0) {\n    return this.createError('object.missing', context, state, options);\n  }\n\n  context.present = present;\n  context.presentWithLabels = internals.keysToLabels(this, present);\n  return this.createError('object.xor', context, state, options);\n};\n\ninternals.oxor = function (key, value, peers, parent, state, options) {\n  const present = [];\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  if (!present.length || present.length === 1) {\n    return;\n  }\n\n  const context = {\n    peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  };\n  context.present = present;\n  context.presentWithLabels = internals.keysToLabels(this, present);\n  return this.createError('object.oxor', context, state, options);\n};\n\ninternals.or = function (key, value, peers, parent, state, options) {\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      return;\n    }\n  }\n\n  return this.createError('object.missing', {\n    peers,\n    peersWithLabels: internals.keysToLabels(this, peers)\n  }, state, options);\n};\n\ninternals.and = function (key, value, peers, parent, state, options) {\n  const missing = [];\n  const present = [];\n  const count = peers.length;\n\n  for (let i = 0; i < count; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist === undefined) {\n      missing.push(peer);\n    } else {\n      present.push(peer);\n    }\n  }\n\n  const aon = missing.length === count || present.length === count;\n\n  if (!aon) {\n    return this.createError('object.and', {\n      present,\n      presentWithLabels: internals.keysToLabels(this, present),\n      missing,\n      missingWithLabels: internals.keysToLabels(this, missing)\n    }, state, options);\n  }\n};\n\ninternals.nand = function (key, value, peers, parent, state, options) {\n  const present = [];\n\n  for (let i = 0; i < peers.length; ++i) {\n    const peer = peers[i];\n    const keysExist = Hoek.reach(parent, peer, {\n      functions: true\n    });\n\n    if (keysExist !== undefined) {\n      present.push(peer);\n    }\n  }\n\n  const main = peers[0];\n  const values = peers.slice(1);\n  const allPresent = present.length === peers.length;\n  return allPresent ? this.createError('object.nand', {\n    main,\n    mainWithLabel: internals.keysToLabels(this, main),\n    peers: values,\n    peersWithLabels: internals.keysToLabels(this, values)\n  }, state, options) : null;\n};\n\nmodule.exports = new internals.Object();","map":{"version":3,"sources":["C:/vidly/vidly/node_modules/joi/lib/types/object/index.js"],"names":["Hoek","require","Topo","Any","Errors","Cast","State","internals","Object","constructor","_type","_inner","children","renames","dependencies","patterns","_init","args","length","keys","_base","value","state","options","target","errors","finish","convert","safeParse","type","_flags","func","Array","isArray","push","createError","create","getPrototypeOf","apply","prototype","clone","valueKeys","i","renamed","rename","isRegExp","targetKeys","matchedTargetKeys","j","from","test","allUndefined","every","key","undefined","ignoreUndefined","multiple","to","abortEarly","hasOwnProperty","call","override","alias","unprocessed","Set","stripProps","child","item","delete","localState","path","reference","result","schema","_validate","_getLabel","reason","strip","finalValue","size","pattern","regex","validate","error","rule","stripUnknown","allowUnknown","skipFunctions","objects","unprocessedKey","dep","hasKey","splitKey","split","err","reach","functions","peers","Err","assert","obj","topo","includes","add","after","_refs","group","cast","_currentJoi","castErr","nodes","append","unknown","allow","limit","Number","isSafeInteger","_test","min","max","RegExp","flags","message","with","arguments","_dependency","without","xor","flatten","oxor","or","and","nand","requiredKeys","applyFunctionToChildren","optionalKeys","forbiddenKeys","applyToDefaults","renameDefaults","fn","root","concat","groupedChildren","groupChildren","remaining","join","describe","shallow","description","rules","arg","ref","toString","isContext","depth","parent","name","typeData","ctor","JSON","parse","parseErr","sort","grouped","childGroup","substring","keysToLabels","findLabel","matchingChild","map","peer","keysExist","main","mainWithLabel","peerWithLabel","present","context","peersWithLabels","presentWithLabels","missing","count","aon","missingWithLabels","values","slice","allPresent","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\nconst Topo = require('topo');\nconst Any = require('../any');\nconst Errors = require('../../errors');\nconst Cast = require('../../cast');\nconst State = require('../state');\n\n\n// Declare internals\n\nconst internals = {};\n\n\ninternals.Object = class extends Any {\n\n    constructor() {\n\n        super();\n        this._type = 'object';\n        this._inner.children = null;\n        this._inner.renames = [];\n        this._inner.dependencies = [];\n        this._inner.patterns = [];\n    }\n\n    _init(...args) {\n\n        return args.length ? this.keys(...args) : this;\n    }\n\n    _base(value, state, options) {\n\n        let target = value;\n        const errors = [];\n        const finish = () => {\n\n            return {\n                value: target,\n                errors: errors.length ? errors : null\n            };\n        };\n\n        if (typeof value === 'string' &&\n            options.convert) {\n\n            value = internals.safeParse(value);\n        }\n\n        const type = this._flags.func ? 'function' : 'object';\n        if (!value ||\n            typeof value !== type ||\n            Array.isArray(value)) {\n\n            errors.push(this.createError(type + '.base', { value }, state, options));\n            return finish();\n        }\n\n        // Skip if there are no other rules to test\n\n        if (!this._inner.renames.length &&\n            !this._inner.dependencies.length &&\n            !this._inner.children &&                    // null allows any keys\n            !this._inner.patterns.length) {\n\n            target = value;\n            return finish();\n        }\n\n        // Ensure target is a local copy (parsed) or shallow copy\n\n        if (target === value) {\n            if (type === 'object') {\n                target = Object.create(Object.getPrototypeOf(value));\n            }\n            else {\n                target = function (...args) {\n\n                    return value.apply(this, args);\n                };\n\n                target.prototype = Hoek.clone(value.prototype);\n            }\n\n            const valueKeys = Object.keys(value);\n            for (let i = 0; i < valueKeys.length; ++i) {\n                target[valueKeys[i]] = value[valueKeys[i]];\n            }\n        }\n        else {\n            target = value;\n        }\n\n        // Rename keys\n\n        const renamed = {};\n        for (let i = 0; i < this._inner.renames.length; ++i) {\n            const rename = this._inner.renames[i];\n\n            if (rename.isRegExp) {\n                const targetKeys = Object.keys(target);\n                const matchedTargetKeys = [];\n\n                for (let j = 0; j < targetKeys.length; ++j) {\n                    if (rename.from.test(targetKeys[j])) {\n                        matchedTargetKeys.push(targetKeys[j]);\n                    }\n                }\n\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\n                if (rename.options.ignoreUndefined && allUndefined) {\n                    continue;\n                }\n\n                if (!rename.options.multiple &&\n                    renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\n                    !rename.options.override &&\n                    !renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (allUndefined) {\n                    delete target[rename.to];\n                }\n                else {\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\n                }\n\n                renamed[rename.to] = true;\n\n                if (!rename.options.alias) {\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\n                        delete target[matchedTargetKeys[j]];\n                    }\n                }\n            }\n            else {\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\n                    continue;\n                }\n\n                if (!rename.options.multiple &&\n                    renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\n                    !rename.options.override &&\n                    !renamed[rename.to]) {\n\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n\n                if (target[rename.from] === undefined) {\n                    delete target[rename.to];\n                }\n                else {\n                    target[rename.to] = target[rename.from];\n                }\n\n                renamed[rename.to] = true;\n\n                if (!rename.options.alias) {\n                    delete target[rename.from];\n                }\n            }\n        }\n\n        // Validate schema\n\n        if (!this._inner.children &&            // null allows any keys\n            !this._inner.patterns.length &&\n            !this._inner.dependencies.length) {\n\n            return finish();\n        }\n\n        const unprocessed = new Set(Object.keys(target));\n\n        if (this._inner.children) {\n            const stripProps = [];\n\n            for (let i = 0; i < this._inner.children.length; ++i) {\n                const child = this._inner.children[i];\n                const key = child.key;\n                const item = target[key];\n\n                unprocessed.delete(key);\n\n                const localState = new State(key, [...state.path, key], target, state.reference);\n                const result = child.schema._validate(item, localState, options);\n                if (result.errors) {\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\n\n                    if (options.abortEarly) {\n                        return finish();\n                    }\n                }\n                else {\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\n                        stripProps.push(key);\n                        target[key] = result.finalValue;\n                    }\n                    else if (result.value !== undefined) {\n                        target[key] = result.value;\n                    }\n                }\n            }\n\n            for (let i = 0; i < stripProps.length; ++i) {\n                delete target[stripProps[i]];\n            }\n        }\n\n        // Unknown keys\n\n        if (unprocessed.size && this._inner.patterns.length) {\n\n            for (const key of unprocessed) {\n                const localState = new State(key, [...state.path, key], target, state.reference);\n                const item = target[key];\n\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\n                    const pattern = this._inner.patterns[i];\n\n                    if (pattern.regex ?\n                        pattern.regex.test(key) :\n                        !pattern.schema.validate(key).error) {\n\n                        unprocessed.delete(key);\n\n                        const result = pattern.rule._validate(item, localState, options);\n                        if (result.errors) {\n                            errors.push(this.createError('object.child', {\n                                key,\n                                child: pattern.rule._getLabel(key),\n                                reason: result.errors\n                            }, localState, options));\n\n                            if (options.abortEarly) {\n                                return finish();\n                            }\n                        }\n\n                        target[key] = result.value;\n                    }\n                }\n            }\n        }\n\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\n                options.skipFunctions) {\n\n                const stripUnknown = options.stripUnknown\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\n                    : false;\n\n\n                for (const key of unprocessed) {\n                    if (stripUnknown) {\n                        delete target[key];\n                        unprocessed.delete(key);\n                    }\n                    else if (typeof target[key] === 'function') {\n                        unprocessed.delete(key);\n                    }\n                }\n            }\n\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\n\n                for (const unprocessedKey of unprocessed) {\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {\n                        key: unprocessedKey,\n                        path: [...state.path, unprocessedKey]\n                    }, options, {}));\n                }\n            }\n        }\n\n        // Validate dependencies\n\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\n            const dep = this._inner.dependencies[i];\n            const hasKey = dep.key !== null;\n            const splitKey = hasKey && dep.key.split('.');\n            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);\n            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key, { functions: true }), dep.peers, target, localState, options);\n            if (err instanceof Errors.Err) {\n                errors.push(err);\n                if (options.abortEarly) {\n                    return finish();\n                }\n            }\n        }\n\n        return finish();\n    }\n\n    keys(schema) {\n\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\n\n        const obj = this.clone();\n\n        if (!schema) {\n            obj._inner.children = null;\n            return obj;\n        }\n\n        const children = Object.keys(schema);\n\n        if (!children.length) {\n            obj._inner.children = [];\n            return obj;\n        }\n\n        const topo = new Topo();\n        if (obj._inner.children) {\n            for (let i = 0; i < obj._inner.children.length; ++i) {\n                const child = obj._inner.children[i];\n\n                // Only add the key if we are not going to replace it later\n                if (!children.includes(child.key)) {\n                    topo.add(child, { after: child._refs, group: child.key });\n                }\n            }\n        }\n\n        for (let i = 0; i < children.length; ++i) {\n            const key = children[i];\n            const child = schema[key];\n            try {\n                const cast = Cast.schema(this._currentJoi, child);\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\n            }\n            catch (castErr) {\n                if (castErr.hasOwnProperty('path')) {\n                    castErr.path = key + '.' + castErr.path;\n                }\n                else {\n                    castErr.path = key;\n                }\n\n                throw castErr;\n            }\n        }\n\n        obj._inner.children = topo.nodes;\n\n        return obj;\n    }\n\n    append(schema) {\n        // Skip any changes\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\n            return this;\n        }\n\n        return this.keys(schema);\n    }\n\n    unknown(allow) {\n\n        const value = allow !== false;\n\n        if (this._flags.allowUnknown === value) {\n            return this;\n        }\n\n        const obj = this.clone();\n        obj._flags.allowUnknown = value;\n        return obj;\n    }\n\n    length(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('length', limit, function (value, state, options) {\n\n            if (Object.keys(value).length === limit) {\n                return value;\n            }\n\n            return this.createError('object.length', { limit, value }, state, options);\n        });\n    }\n\n    min(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('min', limit, function (value, state, options) {\n\n            if (Object.keys(value).length >= limit) {\n                return value;\n            }\n\n            return this.createError('object.min', { limit, value }, state, options);\n        });\n    }\n\n    max(limit) {\n\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\n\n        return this._test('max', limit, function (value, state, options) {\n\n            if (Object.keys(value).length <= limit) {\n                return value;\n            }\n\n            return this.createError('object.max', { limit, value }, state, options);\n        });\n    }\n\n    pattern(pattern, schema) {\n\n        const isRegExp = pattern instanceof RegExp;\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\n        Hoek.assert(schema !== undefined, 'Invalid rule');\n\n        if (isRegExp) {\n            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n        }\n\n        try {\n            schema = Cast.schema(this._currentJoi, schema);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.message = `${castErr.message}(${castErr.path})`;\n            }\n\n            throw castErr;\n        }\n\n        const obj = this.clone();\n        if (isRegExp) {\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\n        }\n        else {\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\n        }\n\n        return obj;\n    }\n\n    schema() {\n\n        return this._test('schema', null, function (value, state, options) {\n\n            if (value instanceof Any) {\n                return value;\n            }\n\n            return this.createError('object.schema', null, state, options);\n        });\n    }\n\n    with(key, peers) {\n\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n\n        return this._dependency('with', key, peers);\n    }\n\n    without(key, peers) {\n\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\n\n        return this._dependency('without', key, peers);\n    }\n\n    xor(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('xor', null, peers);\n    }\n\n    oxor(...peers) {\n\n        return this._dependency('oxor', null, peers);\n    }\n\n    or(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('or', null, peers);\n    }\n\n    and(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('and', null, peers);\n    }\n\n    nand(...peers) {\n\n        peers = Hoek.flatten(peers);\n        return this._dependency('nand', null, peers);\n    }\n\n    requiredKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'required');\n    }\n\n    optionalKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'optional');\n    }\n\n    forbiddenKeys(...children) {\n\n        children = Hoek.flatten(children);\n        return this.applyFunctionToChildren(children, 'forbidden');\n    }\n\n    rename(from, to, options) {\n\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\n\n        for (let i = 0; i < this._inner.renames.length; ++i) {\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\n        }\n\n        const obj = this.clone();\n\n        obj._inner.renames.push({\n            from,\n            to,\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\n            isRegExp: from instanceof RegExp\n        });\n\n        return obj;\n    }\n\n    applyFunctionToChildren(children, fn, args = [], root) {\n\n        children = [].concat(children);\n        Hoek.assert(children.length > 0, 'expected at least one children');\n\n        const groupedChildren = internals.groupChildren(children);\n        let obj;\n\n        if ('' in groupedChildren) {\n            obj = this[fn](...args);\n            delete groupedChildren[''];\n        }\n        else {\n            obj = this.clone();\n        }\n\n        if (obj._inner.children) {\n            root = root ? (root + '.') : '';\n\n            for (let i = 0; i < obj._inner.children.length; ++i) {\n                const child = obj._inner.children[i];\n                const group = groupedChildren[child.key];\n\n                if (group) {\n                    obj._inner.children[i] = {\n                        key: child.key,\n                        _refs: child._refs,\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\n                    };\n\n                    delete groupedChildren[child.key];\n                }\n            }\n        }\n\n        const remaining = Object.keys(groupedChildren);\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\n\n        return obj;\n    }\n\n    _dependency(type, key, peers) {\n\n        peers = [].concat(peers);\n        for (let i = 0; i < peers.length; ++i) {\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\n        }\n\n        const obj = this.clone();\n        obj._inner.dependencies.push({ type, key, peers });\n        return obj;\n    }\n\n    describe(shallow) {\n\n        const description = super.describe();\n\n        if (description.rules) {\n            for (let i = 0; i < description.rules.length; ++i) {\n                const rule = description.rules[i];\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\n                if (/* $lab:coverage:off$ */rule.arg &&\n                    typeof rule.arg === 'object' &&\n                    rule.arg.schema &&\n                    rule.arg.ref /* $lab:coverage:on$ */) {\n                    rule.arg = {\n                        schema: rule.arg.schema.describe(),\n                        ref: rule.arg.ref.toString()\n                    };\n                }\n            }\n        }\n\n        if (this._inner.children &&\n            !shallow) {\n\n            description.children = {};\n            for (let i = 0; i < this._inner.children.length; ++i) {\n                const child = this._inner.children[i];\n                description.children[child.key] = child.schema.describe();\n            }\n        }\n\n        if (this._inner.dependencies.length) {\n            description.dependencies = Hoek.clone(this._inner.dependencies);\n        }\n\n        if (this._inner.patterns.length) {\n            description.patterns = [];\n\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\n                const pattern = this._inner.patterns[i];\n                if (pattern.regex) {\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\n                }\n                else {\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\n                }\n            }\n        }\n\n        if (this._inner.renames.length > 0) {\n            description.renames = Hoek.clone(this._inner.renames);\n        }\n\n        return description;\n    }\n\n    assert(ref, schema, message) {\n\n        ref = Cast.ref(ref);\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\n        message = message || 'pass the assertion test';\n        Hoek.assert(typeof message === 'string', 'Message must be a string');\n\n        try {\n            schema = Cast.schema(this._currentJoi, schema);\n        }\n        catch (castErr) {\n            if (castErr.hasOwnProperty('path')) {\n                castErr.message = `${castErr.message}(${castErr.path})`;\n            }\n\n            throw castErr;\n        }\n\n        const key = ref.path[ref.path.length - 1];\n        const path = ref.path.join('.');\n\n        return this._test('assert', { schema, ref }, function (value, state, options) {\n\n            const result = schema._validate(ref(value), null, options, value);\n            if (!result.errors) {\n                return value;\n            }\n\n            const localState = new State(key, ref.path, state.parent, state.reference);\n            return this.createError('object.assert', { ref: path, message }, localState, options);\n        });\n    }\n\n    type(constructor, name = constructor.name) {\n\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\n        const typeData = {\n            name,\n            ctor: constructor\n        };\n\n        return this._test('type', typeData, function (value, state, options) {\n\n            if (value instanceof constructor) {\n                return value;\n            }\n\n            return this.createError('object.type', { type: typeData.name, value }, state, options);\n        });\n    }\n};\n\ninternals.safeParse = function (value) {\n\n    try {\n        return JSON.parse(value);\n    }\n    catch (parseErr) {}\n\n    return value;\n};\n\n\ninternals.renameDefaults = {\n    alias: false,                   // Keep old value in place\n    multiple: false,                // Allow renaming multiple keys into the same target\n    override: false                 // Overrides an existing key\n};\n\n\ninternals.groupChildren = function (children) {\n\n    children.sort();\n\n    const grouped = {};\n\n    for (let i = 0; i < children.length; ++i) {\n        const child = children[i];\n        Hoek.assert(typeof child === 'string', 'children must be strings');\n        const group = child.split('.')[0];\n        const childGroup = grouped[group] = (grouped[group] || []);\n        childGroup.push(child.substring(group.length + 1));\n    }\n\n    return grouped;\n};\n\n\ninternals.keysToLabels = function (schema, keys) {\n\n    const children = schema._inner.children;\n\n    if (!children) {\n        return keys;\n    }\n\n    const findLabel = function (key) {\n\n        const matchingChild = schema._currentJoi.reach(schema, key);\n        return matchingChild ? matchingChild._getLabel(key) : key;\n    };\n\n    if (Array.isArray(keys)) {\n        return keys.map(findLabel);\n    }\n\n    return findLabel(keys);\n};\n\n\ninternals.with = function (key, value, peers, parent, state, options) {\n\n    if (value === undefined) {\n        return;\n    }\n\n    for (let i = 0; i < peers.length; ++i) {\n\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist === undefined) {\n\n            return this.createError('object.with', {\n                main: key,\n                mainWithLabel: internals.keysToLabels(this, key),\n                peer,\n                peerWithLabel: internals.keysToLabels(this, peer)\n            }, state, options);\n        }\n    }\n};\n\n\ninternals.without = function (key, value, peers, parent, state, options) {\n\n    if (value === undefined) {\n        return;\n    }\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n\n            return this.createError('object.without', {\n                main: key,\n                mainWithLabel: internals.keysToLabels(this, key),\n                peer,\n                peerWithLabel: internals.keysToLabels(this, peer)\n            }, state, options);\n        }\n    }\n};\n\n\ninternals.xor = function (key, value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n            present.push(peer);\n        }\n    }\n\n    if (present.length === 1) {\n        return;\n    }\n\n    const context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };\n\n    if (present.length === 0) {\n        return this.createError('object.missing', context, state, options);\n    }\n\n    context.present = present;\n    context.presentWithLabels = internals.keysToLabels(this, present);\n\n    return this.createError('object.xor', context, state, options);\n};\n\n\ninternals.oxor = function (key, value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n            present.push(peer);\n        }\n    }\n\n    if (!present.length ||\n        present.length === 1) {\n\n        return;\n    }\n\n    const context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };\n    context.present = present;\n    context.presentWithLabels = internals.keysToLabels(this, present);\n\n    return this.createError('object.oxor', context, state, options);\n};\n\n\ninternals.or = function (key, value, peers, parent, state, options) {\n\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n            return;\n        }\n    }\n\n    return this.createError('object.missing', {\n        peers,\n        peersWithLabels: internals.keysToLabels(this, peers)\n    }, state, options);\n};\n\n\ninternals.and = function (key, value, peers, parent, state, options) {\n\n    const missing = [];\n    const present = [];\n    const count = peers.length;\n    for (let i = 0; i < count; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist === undefined) {\n\n            missing.push(peer);\n        }\n        else {\n            present.push(peer);\n        }\n    }\n\n    const aon = (missing.length === count || present.length === count);\n\n    if (!aon) {\n\n        return this.createError('object.and', {\n            present,\n            presentWithLabels: internals.keysToLabels(this, present),\n            missing,\n            missingWithLabels: internals.keysToLabels(this, missing)\n        }, state, options);\n    }\n};\n\n\ninternals.nand = function (key, value, peers, parent, state, options) {\n\n    const present = [];\n    for (let i = 0; i < peers.length; ++i) {\n        const peer = peers[i];\n        const keysExist = Hoek.reach(parent, peer, { functions: true });\n        if (keysExist !== undefined) {\n\n            present.push(peer);\n        }\n    }\n\n    const main = peers[0];\n    const values = peers.slice(1);\n    const allPresent = (present.length === peers.length);\n    return allPresent ? this.createError('object.nand', {\n        main,\n        mainWithLabel: internals.keysToLabels(this, main),\n        peers: values,\n        peersWithLabels: internals.keysToLabels(this, values)\n    }, state, options) : null;\n};\n\n\nmodule.exports = new internals.Object();\n"]},"metadata":{},"sourceType":"script"}