{"ast":null,"code":"'use strict'; // Load modules\n\nconst Hoek = require('hoek'); // Declare internals\n\n\nconst internals = {};\nmodule.exports = class Topo {\n  constructor() {\n    this._items = [];\n    this.nodes = [];\n  }\n\n  add(nodes, options) {\n    options = options || {}; // Validate rules\n\n    const before = [].concat(options.before || []);\n    const after = [].concat(options.after || []);\n    const group = options.group || '?';\n    const sort = options.sort || 0; // Used for merging only\n\n    Hoek.assert(!before.includes(group), `Item cannot come before itself: ${group}`);\n    Hoek.assert(!before.includes('?'), 'Item cannot come before unassociated items');\n    Hoek.assert(!after.includes(group), `Item cannot come after itself: ${group}`);\n    Hoek.assert(!after.includes('?'), 'Item cannot come after unassociated items');\n    [].concat(nodes).forEach((node, i) => {\n      const item = {\n        seq: this._items.length,\n        sort,\n        before,\n        after,\n        group,\n        node\n      };\n\n      this._items.push(item);\n    }); // Insert event\n\n    const error = this._sort();\n\n    Hoek.assert(!error, 'item', group !== '?' ? `added into group ${group}` : '', 'created a dependencies error');\n    return this.nodes;\n  }\n\n  merge(others) {\n    others = [].concat(others);\n\n    for (let i = 0; i < others.length; ++i) {\n      const other = others[i];\n\n      if (other) {\n        for (let j = 0; j < other._items.length; ++j) {\n          const item = Object.assign({}, other._items[j]); // Shallow cloned\n\n          this._items.push(item);\n        }\n      }\n    } // Sort items\n\n\n    this._items.sort(internals.mergeSort);\n\n    for (let i = 0; i < this._items.length; ++i) {\n      this._items[i].seq = i;\n    }\n\n    const error = this._sort();\n\n    Hoek.assert(!error, 'merge created a dependencies error');\n    return this.nodes;\n  }\n\n  _sort() {\n    // Construct graph\n    const graph = {};\n    const graphAfters = Object.create(null); // A prototype can bungle lookups w/ false positives\n\n    const groups = Object.create(null);\n\n    for (let i = 0; i < this._items.length; ++i) {\n      const item = this._items[i];\n      const seq = item.seq; // Unique across all items\n\n      const group = item.group; // Determine Groups\n\n      groups[group] = groups[group] || [];\n      groups[group].push(seq); // Build intermediary graph using 'before'\n\n      graph[seq] = item.before; // Build second intermediary graph with 'after'\n\n      const after = item.after;\n\n      for (let j = 0; j < after.length; ++j) {\n        graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);\n      }\n    } // Expand intermediary graph\n\n\n    let graphNodes = Object.keys(graph);\n\n    for (let i = 0; i < graphNodes.length; ++i) {\n      const node = graphNodes[i];\n      const expandedGroups = [];\n      const graphNodeItems = Object.keys(graph[node]);\n\n      for (let j = 0; j < graphNodeItems.length; ++j) {\n        const group = graph[node][graphNodeItems[j]];\n        groups[group] = groups[group] || [];\n\n        for (let k = 0; k < groups[group].length; ++k) {\n          expandedGroups.push(groups[group][k]);\n        }\n      }\n\n      graph[node] = expandedGroups;\n    } // Merge intermediary graph using graphAfters into final graph\n\n\n    const afterNodes = Object.keys(graphAfters);\n\n    for (let i = 0; i < afterNodes.length; ++i) {\n      const group = afterNodes[i];\n\n      if (groups[group]) {\n        for (let j = 0; j < groups[group].length; ++j) {\n          const node = groups[group][j];\n          graph[node] = graph[node].concat(graphAfters[group]);\n        }\n      }\n    } // Compile ancestors\n\n\n    let children;\n    const ancestors = {};\n    graphNodes = Object.keys(graph);\n\n    for (let i = 0; i < graphNodes.length; ++i) {\n      const node = graphNodes[i];\n      children = graph[node];\n\n      for (let j = 0; j < children.length; ++j) {\n        ancestors[children[j]] = (ancestors[children[j]] || []).concat(node);\n      }\n    } // Topo sort\n\n\n    const visited = {};\n    const sorted = [];\n\n    for (let i = 0; i < this._items.length; ++i) {\n      // Really looping thru item.seq values out of order\n      let next = i;\n\n      if (ancestors[i]) {\n        next = null;\n\n        for (let j = 0; j < this._items.length; ++j) {\n          // As above, these are item.seq values\n          if (visited[j] === true) {\n            continue;\n          }\n\n          if (!ancestors[j]) {\n            ancestors[j] = [];\n          }\n\n          const shouldSeeCount = ancestors[j].length;\n          let seenCount = 0;\n\n          for (let k = 0; k < shouldSeeCount; ++k) {\n            if (visited[ancestors[j][k]]) {\n              ++seenCount;\n            }\n          }\n\n          if (seenCount === shouldSeeCount) {\n            next = j;\n            break;\n          }\n        }\n      }\n\n      if (next !== null) {\n        visited[next] = true;\n        sorted.push(next);\n      }\n    }\n\n    if (sorted.length !== this._items.length) {\n      return new Error('Invalid dependencies');\n    }\n\n    const seqIndex = {};\n\n    for (let i = 0; i < this._items.length; ++i) {\n      const item = this._items[i];\n      seqIndex[item.seq] = item;\n    }\n\n    const sortedNodes = [];\n    this._items = sorted.map(value => {\n      const sortedItem = seqIndex[value];\n      sortedNodes.push(sortedItem.node);\n      return sortedItem;\n    });\n    this.nodes = sortedNodes;\n  }\n\n};\n\ninternals.mergeSort = (a, b) => {\n  return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;\n};","map":{"version":3,"sources":["C:/vidly/vidly/node_modules/topo/lib/index.js"],"names":["Hoek","require","internals","module","exports","Topo","constructor","_items","nodes","add","options","before","concat","after","group","sort","assert","includes","forEach","node","i","item","seq","length","push","error","_sort","merge","others","other","j","Object","assign","mergeSort","graph","graphAfters","create","groups","graphNodes","keys","expandedGroups","graphNodeItems","k","afterNodes","children","ancestors","visited","sorted","next","shouldSeeCount","seenCount","Error","seqIndex","sortedNodes","map","value","sortedItem","a","b"],"mappings":"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","sourcesContent":["'use strict';\n\n// Load modules\n\nconst Hoek = require('hoek');\n\n\n// Declare internals\n\nconst internals = {};\n\n\nmodule.exports = class Topo {\n\n    constructor() {\n\n        this._items = [];\n        this.nodes = [];\n    }\n\n    add(nodes, options) {\n\n        options = options || {};\n\n        // Validate rules\n\n        const before = [].concat(options.before || []);\n        const after = [].concat(options.after || []);\n        const group = options.group || '?';\n        const sort = options.sort || 0;                   // Used for merging only\n\n        Hoek.assert(!before.includes(group), `Item cannot come before itself: ${group}`);\n        Hoek.assert(!before.includes('?'), 'Item cannot come before unassociated items');\n        Hoek.assert(!after.includes(group), `Item cannot come after itself: ${group}`);\n        Hoek.assert(!after.includes('?'), 'Item cannot come after unassociated items');\n\n        ([].concat(nodes)).forEach((node, i) => {\n\n            const item = {\n                seq: this._items.length,\n                sort,\n                before,\n                after,\n                group,\n                node\n            };\n\n            this._items.push(item);\n        });\n\n        // Insert event\n\n        const error = this._sort();\n        Hoek.assert(!error, 'item', (group !== '?' ? `added into group ${group}` : ''), 'created a dependencies error');\n\n        return this.nodes;\n    }\n\n    merge(others) {\n\n        others = [].concat(others);\n        for (let i = 0; i < others.length; ++i) {\n            const other = others[i];\n            if (other) {\n                for (let j = 0; j < other._items.length; ++j) {\n                    const item = Object.assign({}, other._items[j]);        // Shallow cloned\n                    this._items.push(item);\n                }\n            }\n        }\n\n        // Sort items\n\n        this._items.sort(internals.mergeSort);\n        for (let i = 0; i < this._items.length; ++i) {\n            this._items[i].seq = i;\n        }\n\n        const error = this._sort();\n        Hoek.assert(!error, 'merge created a dependencies error');\n\n        return this.nodes;\n    }\n\n    _sort() {\n\n        // Construct graph\n\n        const graph = {};\n        const graphAfters = Object.create(null); // A prototype can bungle lookups w/ false positives\n        const groups = Object.create(null);\n\n        for (let i = 0; i < this._items.length; ++i) {\n            const item = this._items[i];\n            const seq = item.seq;                         // Unique across all items\n            const group = item.group;\n\n            // Determine Groups\n\n            groups[group] = groups[group] || [];\n            groups[group].push(seq);\n\n            // Build intermediary graph using 'before'\n\n            graph[seq] = item.before;\n\n            // Build second intermediary graph with 'after'\n\n            const after = item.after;\n            for (let j = 0; j < after.length; ++j) {\n                graphAfters[after[j]] = (graphAfters[after[j]] || []).concat(seq);\n            }\n        }\n\n        // Expand intermediary graph\n\n        let graphNodes = Object.keys(graph);\n        for (let i = 0; i < graphNodes.length; ++i) {\n            const node = graphNodes[i];\n            const expandedGroups = [];\n\n            const graphNodeItems = Object.keys(graph[node]);\n            for (let j = 0; j < graphNodeItems.length; ++j) {\n                const group = graph[node][graphNodeItems[j]];\n                groups[group] = groups[group] || [];\n\n                for (let k = 0; k < groups[group].length; ++k) {\n                    expandedGroups.push(groups[group][k]);\n                }\n            }\n\n            graph[node] = expandedGroups;\n        }\n\n        // Merge intermediary graph using graphAfters into final graph\n\n        const afterNodes = Object.keys(graphAfters);\n        for (let i = 0; i < afterNodes.length; ++i) {\n            const group = afterNodes[i];\n\n            if (groups[group]) {\n                for (let j = 0; j < groups[group].length; ++j) {\n                    const node = groups[group][j];\n                    graph[node] = graph[node].concat(graphAfters[group]);\n                }\n            }\n        }\n\n        // Compile ancestors\n\n        let children;\n        const ancestors = {};\n        graphNodes = Object.keys(graph);\n        for (let i = 0; i < graphNodes.length; ++i) {\n            const node = graphNodes[i];\n            children = graph[node];\n\n            for (let j = 0; j < children.length; ++j) {\n                ancestors[children[j]] = (ancestors[children[j]] || []).concat(node);\n            }\n        }\n\n        // Topo sort\n\n        const visited = {};\n        const sorted = [];\n\n        for (let i = 0; i < this._items.length; ++i) {          // Really looping thru item.seq values out of order\n            let next = i;\n\n            if (ancestors[i]) {\n                next = null;\n                for (let j = 0; j < this._items.length; ++j) {  // As above, these are item.seq values\n                    if (visited[j] === true) {\n                        continue;\n                    }\n\n                    if (!ancestors[j]) {\n                        ancestors[j] = [];\n                    }\n\n                    const shouldSeeCount = ancestors[j].length;\n                    let seenCount = 0;\n                    for (let k = 0; k < shouldSeeCount; ++k) {\n                        if (visited[ancestors[j][k]]) {\n                            ++seenCount;\n                        }\n                    }\n\n                    if (seenCount === shouldSeeCount) {\n                        next = j;\n                        break;\n                    }\n                }\n            }\n\n            if (next !== null) {\n                visited[next] = true;\n                sorted.push(next);\n            }\n        }\n\n        if (sorted.length !== this._items.length) {\n            return new Error('Invalid dependencies');\n        }\n\n        const seqIndex = {};\n        for (let i = 0; i < this._items.length; ++i) {\n            const item = this._items[i];\n            seqIndex[item.seq] = item;\n        }\n\n        const sortedNodes = [];\n        this._items = sorted.map((value) => {\n\n            const sortedItem = seqIndex[value];\n            sortedNodes.push(sortedItem.node);\n            return sortedItem;\n        });\n\n        this.nodes = sortedNodes;\n    }\n};\n\ninternals.mergeSort = (a, b) => {\n\n    return a.sort === b.sort ? 0 : (a.sort < b.sort ? -1 : 1);\n};\n"]},"metadata":{},"sourceType":"script"}